<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Go - Daemon365</title><link rel=icon href=/imgs/favicon.ico><link rel=manifest href=/manifest.json><meta name=theme-color content="#007aff"><meta name=mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="default"><meta name=apple-mobile-web-app-title content="Daemon365"><link rel=alternate type=application/rss+xml title=Daemon365 href=https://daemon365.dev/categories/go/index.xml><meta name=description content="Don't let yourself stop."><meta name=keywords content="[Go Golang Linux Docker Kubernetes DevOps Cloud Native Open Source Daemon365]"><meta name=author content="daemon365"><meta property="og:type" content="website"><meta property="og:url" content="https://daemon365.dev/categories/go/"><meta property="og:title" content="Go - Daemon365"><meta property="og:description" content="Don't let yourself stop."><meta property="og:image" content="https://daemon365.dev/imgs/avatar.svg"><meta property="og:locale" content="en"><meta property="og:site_name" content="Daemon365"><meta name=twitter:card content="summary_large_image"><meta name=twitter:url content="https://daemon365.dev/categories/go/"><meta name=twitter:title content="Go - Daemon365"><meta name=twitter:description content="Don't let yourself stop."><meta name=twitter:image content="https://daemon365.dev/imgs/avatar.svg"><link rel=canonical href=https://daemon365.dev/categories/go/><link rel=alternate type=application/rss+xml title=Daemon365 href=https://daemon365.dev/categories/go/index.xml><script type=application/ld+json>{"@context":"https://schema.org","@type":"WebSite","name":"Daemon365","url":"https:\/\/daemon365.dev\/","description":"Don\u0027t let yourself stop.","publisher":{"@type":"Organization","name":"Daemon365"},"inLanguage":"en"}</script><meta name=robots content="index, follow"><meta name=googlebot content="index, follow"><link rel=stylesheet href=/css/components/variables.css><link rel=stylesheet href=/css/components/base.css><link rel=stylesheet href=/css/components/layout.css><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/css/components/search.css><link rel=stylesheet href=/css/components/toc.css><link rel=stylesheet href=/css/components/image-preview.css><link rel=stylesheet href=/css/components/reading-progress.css><style>:root{font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,helvetica neue,Arial,sans-serif}</style></head><body><div class=reading-progress-bar></div><header class=site-header><div class=container><div class=header-content><div class=site-branding><a href=/ class=site-logo><span class=site-title>Daemon365</span></a></div><nav class=site-nav><ul class=nav-menu><li><a href=/><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
首页</a></li><li><a href=/about><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>
关于</a></li><li><a href=/archives><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/></svg>
归档</a></li><li><a href=/categories class=active><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>
分类</a></li><li><a href=/tags><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg>
标签</a></li><li><button class=search-trigger aria-label=Search>
<svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>
搜索</button></li></ul></nav></div></div></header><main class=main-content><div class=taxonomy-term-container><div class=container><header class=page-header><h1 class=page-title><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>
Go</h1><p class=taxonomy-count><strong>40</strong> posts</p></header><div class=posts-list><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/go_channel_code/>Go channel 原理</a></h3><div class=post-meta><time datetime=2024-12-22><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2024-12-22
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
9 min read</span></div><p class=post-summary>作用 Go 语言的 channel 是一种 goroutine 之间的通信方式，它可以用来传递数据，也可以用来同步 goroutine 的执行。 chan 是 goroutine 之间的通信桥梁，可以安全地在多个 goroutine 中共享数据。 使用 chan 实现 goroutine 之间的协作 …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/go_gc_code/>Go 垃圾回收原理</a></h3><div class=post-meta><time datetime=2024-12-17><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2024-12-17
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
13 min read</span></div><p class=post-summary>*** Go 代码基于 v1.23.0 ***
介绍 golang GC 垃圾回收机制 触发条件 用户调用 runtime.GC 主动触发 Go 程序检测到距上次 GC 内存分配增长超过一定比例时（默认 100%）触发 定时触发 （默认 2 min） 定时触发 代码在 …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/go_memory_code/>go 内存管理</a></h3><div class=post-meta><time datetime=2024-12-10><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2024-12-10
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
15 min read</span></div><p class=post-summary>操作系统内存管理 操作系统管理内存的存储单元是页（page），在 linux 中一般是 4KB。而且，操作系统还会使用 虚拟内存 来管理内存，在用户程序中，我们看到的内存是不是真实的内存，而是虚拟内存。当访问或者修改内存的时候，操作系统会将虚拟内存映射到真实的内存中。申请内存的组件是 Page …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/gmp_code/>从源码分析 GMP 调度原理</a></h3><div class=post-meta><time datetime=2024-12-07><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2024-12-07
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
15 min read</span></div><p class=post-summary>本身涉及到的 go 代码 都是基于 go 1.23.0 版本
传统 OS 线程 线程是 CPU 的最小调度单位，CPU 通过不断切换线程来实现多任务的并发。这会引发一些问题（对于用户角度）：
线程的创建和销毁等是昂贵的，因为要不断在用户空间和内核空间切换。 线程的调度是由操作系统负责的，用户无法控制 …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/behavioral_patterns/>行为模式</a></h3><div class=post-meta><time datetime=2023-09-25><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2023-09-25
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
10 min read</span></div><p class=post-summary>责任链模式 责任链模式是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。比如 kratos,gin等开源库的中间件实现。
代码实现 package main import ( &amp;#34;context&amp;#34; …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/structural_patterns/>结构型模式</a></h3><div class=post-meta><time datetime=2023-09-24><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2023-09-24
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
6 min read</span></div><p class=post-summary>适配器模式 适配器模式用于转换一种接口适配另一种接口。比如，现在有个借口是对json字符串进行分析等，现在有一些yaml文件也要分析，这时候我我们就应该给yaml字符串就个适配器，转换成json字符串，然后就行分析。
代码实现 package main import ( &amp;#34;fmt&amp;#34; …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/creator_mode/>创建者模式</a></h3><div class=post-meta><time datetime=2023-09-23><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2023-09-23
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
4 min read</span></div><p class=post-summary>单例模式 为什么要用单例模式 保证一个对象只有一个实例 ，减少内存开销。比如一些可以复用一个连接的网络，比如http2 client等，而且可以减少网络开销。
为什么不用个全局变量控制 因为任何代码都有可能覆盖掉那些变量的内容， 从而引发程序崩溃。
代码实现 package main import …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golang_operates_etcd/>golang操作etcd</a></h3><div class=post-meta><time datetime=2023-01-08><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2023-01-08
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
4 min read</span></div><p class=post-summary>etcd是近几年比较火热的一个开源的、分布式的键值对数据存储系统，提供共享配置、服务的注册和发现，本文主要介绍etcd的安装和使用。
etcd介绍 etcd是使用Go语言开发的一个开源的、高可用的分布式key-value存储系统，可以用于配置共享和服务的注册和发现。
类似项目有zookeeper和 …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/go_command_line_tool_cobra/>Go命令行工具cobra</a></h3><div class=post-meta><time datetime=2022-12-21><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2022-12-21
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
2 min read</span></div><p class=post-summary>关于 Cobra 是 Go 的 CLI 框架。它包含一个用于创建功能强大的现代 CLI 应用程序的库，以及一个用于快速生成基于 Cobra 的应用程序和命令文件的工具。
Cobra 由 Go 项目成员和 hugo 作者 spf13 创建，已经被许多流行的 Go 项目采用，比如 …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golang_map_implementation_principle/>golang map实现原理</a></h3><div class=post-meta><time datetime=2021-05-22><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2021-05-22
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
22 min read</span></div><p class=post-summary>这篇文章主要讲 map 的赋值、删除、查询、扩容的具体执行过程，仍然是从底层的角度展开。结合源码，看完本文一定会彻底明白 map 底层原理。
我要说明的是，这里对 map 的基本用法涉及比较少，我相信可以通过阅读其他入门书籍了解。本文的内容比较深入，但是由于我画了各种图，我相信很容易看懂。
什么是 …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/zap_high_performance_log/>zap高性能日志</a></h3><div class=post-meta><time datetime=2021-03-23><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2021-03-23
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
4 min read</span></div><p class=post-summary>摘要 日志在整个工程实践中的重要性不言而喻，在选择日志组件的时候也有多方面的考量。详细、正确和及时的反馈是必不可少的，但是整个性能表现是否也是必要考虑的点呢？在长期的实践中发现有的日志组件对于计算资源的消耗十分巨大，这将导致整个服务成本的居高不下。此文从设计原理深度分析了 zap 的设计与实现上的权 …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golang_channel_principle/>golang channel原理</a></h3><div class=post-meta><time datetime=2021-02-21><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2021-02-21
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
4 min read</span></div><p class=post-summary>channel介绍 channel一个类型管道，通过它可以在goroutine之间发送和接收消息。它是Golang在语言层面提供的goroutine间的通信方式。
众所周知，Go依赖于称为CSP（Communicating Sequential Processes）的并发模型，通过Channel实现 …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golang_gc_garbage_collection_mechanism/>golang GC 垃圾回收机制</a></h3><div class=post-meta><time datetime=2021-02-20><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2021-02-20
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
2 min read</span></div><p class=post-summary>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的对象，让出存储器资源，无需程序员手动执行。
Golang中的垃圾回收主要应用三色标记法，GC过程和其他用户goroutine可并发运行，但需要一定时间的STW(stop the …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/viper_configuration_management/>viper配置管理</a></h3><div class=post-meta><time datetime=2021-01-23><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2021-01-23
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
6 min read</span></div><p class=post-summary>安装 go get github.com/spf13/viper viper支持的功能 1、可以设置默认值 2、可以加载多种格式的配置文件，如JSON，TOML，YAML，HCL和Java属性配置文件 3、应用程序运行过程中，保持监听和重新读取配置文件 4、可以从环境变量读取配置 5、可以从远程配置 …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golanghtml_tag_extractor_soup/>golangHTML标签提取器soup</a></h3><div class=post-meta><time datetime=2021-01-05><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2021-01-05
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
1 min read</span></div><p class=post-summary>什么是soup 类似python中beatifulsoup，用于提取html标签提取，多用于爬虫。它可以很好的处理不规范标记并生成剖析树(parse tree)。 它提供简单又常用的导航，搜索以及修改剖析树的操作。利用它我们不在需要编写正则表达式就可以方便的实现网页信息的提取。soup是一个小型的网 …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golang_jwt/>golang jwt</a></h3><div class=post-meta><time datetime=2020-05-20><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2020-05-20
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
2 min read</span></div><p class=post-summary>什么是JWT？ JWT全称JSON Web Token是一种跨域认证解决方案，属于一个开放的标准，它规定了一种Token实现方式，目前多用于前后端分离项目和OAuth2.0业务场景下。
JWT作用？ JWT就是一种基于Token的轻量级认证模式，服务端认证通过后，会生成一个JSON对象，经过签名后得 …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golang_web_source_code_analysis/>golang web源码解析</a></h3><div class=post-meta><time datetime=2020-03-21><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2020-03-21
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
4 min read</span></div><p class=post-summary>Go的web工作原理 在Go中使用及其简单的代码即可开启一个web服务。如下：
//开启web服务 func test(){ http.HandleFunc(&amp;#34;/&amp;#34;, sayHello) err := http.ListenAndServe(&amp;#34;:9090&amp;#34;,nil) …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golang_sqlx/>golang sqlx</a></h3><div class=post-meta><time datetime=2020-01-13><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2020-01-13
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
6 min read</span></div><p class=post-summary>在项目中我们通常可能会使用database/sql连接MySQL数据库。本文借助使用sqlx实现批量插入数据的例子，介绍了sqlx中可能被你忽视了的sqlx.In和DB.NamedExec方法。
sqlx介绍 在项目中我们通常可能会使用database/sql连接MySQL数据库。sqlx可以认为是 …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golang_redis/>golang redis</a></h3><div class=post-meta><time datetime=2020-01-12><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2020-01-12
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
2 min read</span></div><p class=post-summary>安装 下载第三方包:
go get -u github.com/go-redis/redis/v9 连接 // 定义一个rdis客户端 var redisdb *redis.Client // 初始化 func initClient() (err error) { redisdb = …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golang_nethttp_package/>golang nethttp包</a></h3><div class=post-meta><time datetime=2020-01-11><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2020-01-11
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
4 min read</span></div><p class=post-summary>http协议 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。
关于http(https)协议: …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/nethttp_and_gin_routing/>nethttp和gin 路由</a></h3><div class=post-meta><time datetime=2019-12-23><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2019-12-23
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
8 min read</span></div><p class=post-summary>net/http 路由注册 func test1() { http.HandleFunc(&amp;#34;/&amp;#34;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;#34;Hello world!&amp;#34;) }) err …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/go_mod/>go mod</a></h3><div class=post-meta><time datetime=2019-10-01><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2019-10-01
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
1 min read</span></div><p class=post-summary>go module是 Go1.11版本之后官方推出的版本管理工具，并且从Go1.13版本开始，go module将是Go语言默认的依赖管理工具。
GO111MODULE 要启用go module支持首先要设置环境变量GO111MODULE，通过它可以开启或关闭模块支持，它有三个可选值 …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golang_template_htmltemplate_and_texttemplate/>golang 模板 htmltemplate与texttemplate</a></h3><div class=post-meta><time datetime=2019-07-13><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2019-07-13
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
3 min read</span></div><p class=post-summary>html模板生成: html/template包实现了数据驱动的模板，用于生成可对抗代码注入的安全HTML输出。它提供了和text/template包相同的接口，Go语言中输出HTML的场景都应使用text/template包。 模板语法 {{.}} 模板语法都包含在{{和}}中间，其中{{.}}中 …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golang_reflection/>golang 反射</a></h3><div class=post-meta><time datetime=2019-07-12><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2019-07-12
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
5 min read</span></div><p class=post-summary>变量的内在机制 Go语言中的变量是分为两部分的:
类型信息：预先定义好的元信息。 值信息：程序运行过程中可动态变化的。 反射介绍 反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。
支持反 …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/introduction_and_use_of_gin_framework/>Gin框架介绍及使用</a></h3><div class=post-meta><time datetime=2019-06-30><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2019-06-30
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
6 min read</span></div><p class=post-summary>Gin框架介绍 基于httprouter开发的Web框架。 中文文档，齐全。 简单易用的轻量级框架。 Gin框架安装 go get -u github.com/gin-gonic/gin 实例:
package main import ( &amp;#34;fmt&amp;#34; …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/goalng_package_and_command_tools/>goalng包和命令工具</a></h3><div class=post-meta><time datetime=2019-06-29><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2019-06-29
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
2 min read</span></div><p class=post-summary>包简介 任何包系统设计的目的都是为了简化大型程序的设计和维护工作，通过将一组相关的特性放进一个独立的单元以便于理解和更新，在每个单元更新的同时保持和程序中其它单元的相对独立性。这种模块化的特性允许每个包可以被其它的不同项目共享和重用，在项目范围内、甚至全球范围统一的分发和复用。
每个包一般都定义了一 …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golang_unit_testing/>golang 单元测试</a></h3><div class=post-meta><time datetime=2019-06-29><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2019-06-29
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
9 min read</span></div><p class=post-summary>go test go test命令是一个按照一定的约定和组织来测试代码的程序。在包目录内，所有以_test.go为后缀名的源文件在执行go build时不会被构建成包的一部分，它们是go test测试的一部分。
go test命令会遍历所有的*_test.go文件中符合上述命名规则的函数，生成一个临 …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golang_context_package/>golang context包</a></h3><div class=post-meta><time datetime=2019-06-28><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2019-06-28
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
6 min read</span></div><p class=post-summary>go context标准库 context包在Go1.7版本时加入到标准库中。其设计目标是给Golang提供一个标准接口来给其他任务发送取消信号和传递数据。其具体作用为：
可以通过context发送取消信号。
可以指定截止时间（Deadline)，context在截止时间到期后自动发送取消信号。
可 …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golang_channel/>golang channel</a></h3><div class=post-meta><time datetime=2019-06-26><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2019-06-26
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
2 min read</span></div><p class=post-summary>什么是channel channels 是一种类型安全的消息队列，充当两个 goroutine 之间的管道，将通过它同步的进行任意资源的交换。chan 控制 goroutines 交互的能力从而创建了 Go 同步机制。当创建的 chan 没有容量时，称为无缓冲通道。反过来，使用容量创建的 chan …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golang_concurrency/>golang并发</a></h3><div class=post-meta><time datetime=2019-06-26><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2019-06-26
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
3 min read</span></div><p class=post-summary>goroutine goroutine是Go并行设计的核心。goroutine说到底其实就是线程，但是它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据 …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/go_language_file_system/>go语言文件系统</a></h3><div class=post-meta><time datetime=2019-06-23><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2019-06-23
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
2 min read</span></div><p class=post-summary>检测文件是否存在 //存在返回 true，不存在返回 false func fileIfExist(filename string) bool { _, err := os.Stat(filename) if nil != err { fmt.Println(filename, &amp;#34;is …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golang_function/>golang函数</a></h3><div class=post-meta><time datetime=2019-06-22><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2019-06-22
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
2 min read</span></div><p class=post-summary>函数声明 函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。
func function-name(param...) (result...) { body } 形式参数列表描述了函数的参数名以及参数类型。这些参数作为局部变量，其值由参数调用者提供。返回值列表描述了函数返回值的变量名 …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golang_basic_types/>golang基础类型</a></h3><div class=post-meta><time datetime=2019-06-22><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2019-06-22
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
2 min read</span></div><p class=post-summary>整型 Go语言同时提供了有符号和无符号类型的整数运算。这里有int8、int16、int32和int64四种截然不同大小的有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，与此对应的是uint8、uint16、uint32和uint64四种无符号整数类型。
Unicode字符 …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golang_infrastructure/>golang基础结构</a></h3><div class=post-meta><time datetime=2019-06-22><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2019-06-22
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
2 min read</span></div><p class=post-summary>命名 Go语言中的函数名、变量名、常量名、类型名、语句标号和包名等所有的命名,都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头,后面可以跟任意数量的字母、数字或下划线.大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字.
Go语言的关键字 …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golang_complex_data_structure/>golang复杂数据结构</a></h3><div class=post-meta><time datetime=2019-06-22><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2019-06-22
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
2 min read</span></div><p class=post-summary>数组 **数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。**因为数组的长度是固定的，因此在Go语言中很少直接使用数组。
数组的每个元素可以通过索引下标来访问，索引下标的范围是从0开始到数组长度减1的位置。内置的len函数将返回数组中元素的个数。
var a …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golang_interface/>golang接口</a></h3><div class=post-meta><time datetime=2019-06-22><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2019-06-22
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
2 min read</span></div><p class=post-summary>接口的定义 接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。
很多面向对象的语言都有相似的接口概念，但Go语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有 …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golang_method/>golang方法</a></h3><div class=post-meta><time datetime=2019-06-22><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2019-06-22
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
1 min read</span></div><p class=post-summary>方法声明 在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。
package main import &amp;#34;fmt&amp;#34; type People struct { name string age uint8 …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golang_time_package/>golang time包</a></h3><div class=post-meta><time datetime=2019-06-21><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2019-06-21
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
2 min read</span></div><p class=post-summary>时间类型 time.Time类型表示时间。
func demo() { now := time.Now() //获取当前时间 fmt.Printf(&amp;#34;Now:%v\n&amp;#34;, now) // Now:2020-08-19 21:53:31.1633023 +0800 CST …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golang_error_error_handling/>golang error错误处理</a></h3><div class=post-meta><time datetime=2019-06-20><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2019-06-20
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
8 min read</span></div><p class=post-summary>error定义 数据结构 go语言error是一普通的值，实现方式为简单一个接口。
// The error built-in interface type is the conventional interface for // representing an error condition, …</p></div></article><article class=post-card><div class=post-card-content><h3 class=post-title><a href=/post/go/golang_fmt_package/>golang fmt包</a></h3><div class=post-meta><time datetime=2019-06-20><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2019-06-20
</time><span class=reading-time><svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
3 min read</span></div><p class=post-summary>fmt fmt包实现了类似C语言printf和scanf的格式化I/O。主要分为向外输出内容和获取输入内容两大部分。
向外输出 标准库fmt提供了以下几种输出相关函数。
Print Print系列函数会将内容输出到系统的标准输出，区别在于Print函数直接输出内容，Printf函数支持格式化输出字符 …</p></div></article></div></div></div></main><footer class=site-footer><div class=container><div class=footer-content><div class=footer-info><p class=copyright>© 2026 daemon365</p><p class=powered-by>由 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 和 <a href=https://github.com/daemon365/hugo-theme-daemon target=_blank rel=noopener>Daemon</a> 驱动</p></div><div class=social-links><a href=https://github.com/daemon365 target=_blank rel=noopener aria-label=GitHub><svg class="icon" width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0C5.374.0.0 5.373.0 12c0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931.0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176.0.0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221.0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576C20.566 21.797 24 17.3 24 12c0-6.627-5.373-12-12-12z"/></svg>
</a><a href=mailto:daemon365@foxmail.com aria-label=Email><svg class="icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></div></div></div></footer><div class=search-modal id=searchModal><div class=search-modal-backdrop></div><div class=search-modal-content><div class=search-modal-header><input type=text class=search-input id=searchInput placeholder=搜索文章... autofocus>
<button class=search-close aria-label="Close search">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button></div><div class=search-results id=searchResults><p class=search-hint>输入 2 个或更多字符开始搜索</p></div></div></div><script src=/js/components/search.js></script><script src=/js/components/toc.js></script><script src=/js/components/scroll-effects.js></script><script src=/js/components/code-copy.js></script><script src=/js/components/lazy-loading.js></script><script src=/js/components/image-preview.js></script><script src=/js/components/back-to-top.js></script><script src=/js/main-new.js></script><script>"serviceWorker"in navigator&&window.addEventListener("load",()=>{navigator.serviceWorker.register("/sw.js").then(e=>{console.log("Service Worker registered:",e.scope)}).catch(e=>{console.log("Service Worker registration failed:",e)})})</script></body></html>