<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Database on Daemon</title><link>https://daemon365.dev/categories/database/</link><description>Recent content in Database on Daemon</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Sun, 20 Aug 2023 00:00:00 +0800</lastBuildDate><atom:link href="https://daemon365.dev/categories/database/rss.xml" rel="self" type="application/rss+xml"/><item><title>redis主从同步</title><link>https://daemon365.dev/post/database/redis_master_slave_synchronization/</link><pubDate>Sun, 20 Aug 2023 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/database/redis_master_slave_synchronization/</guid><description>&lt;h2 id="redis主从同步">redis主从同步
&lt;a class="header-anchor" href="#redis%e4%b8%bb%e4%bb%8e%e5%90%8c%e6%ad%a5">&lt;/a>
&lt;/h2>&lt;p>&lt;img src="https://daemon365.dev/imgs/img-lazy-loading.gif" data-src="https://daemon365.dev/images/a9aeda50-50ab-4fe3-b94c-572cadf14613.png" alt="" />&lt;/p>
&lt;p>原理：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>从服务器向主服务器发送 SYNC 命令。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接到 SYNC 命令的主服务器会调用BGSAVE 命令，创建一个 RDB 文件，并使用缓冲区记录接下来执行的所有写命令。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>当主服务器执行完 BGSAVE 命令时，它会向从服务器发送 RDB 文件，而从服务器则会接收并载入这个文件。&lt;/p></description></item><item><title>RabbitMQ消息队列</title><link>https://daemon365.dev/post/database/rabbitmq_message_queue/</link><pubDate>Sat, 20 May 2023 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/database/rabbitmq_message_queue/</guid><description>&lt;h2 id="消息队列">消息队列
&lt;a class="header-anchor" href="#%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97">&lt;/a>
&lt;/h2>&lt;p>本篇文章主要介绍了 RabbitMQ 这种消息队列，从消息队列的概念、应用场景、安装方式到它的核心概念、五种工作模式。在安装的时候推荐使用 Docker 方式进行安装。重点需要理解的就是消息队列的应用场景、核心概念和 RabbitMQ 的五种工作模式，其中用的比较多的就是发布订阅模式、主题模式。&lt;/p></description></item><item><title>redis发布订阅</title><link>https://daemon365.dev/post/database/redis_publish_subscribe/</link><pubDate>Sat, 20 Aug 2022 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/database/redis_publish_subscribe/</guid><description>&lt;h2 id="什么是发布和订阅">什么是发布和订阅
&lt;a class="header-anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%8f%91%e5%b8%83%e5%92%8c%e8%ae%a2%e9%98%85">&lt;/a>
&lt;/h2>&lt;p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。&lt;/p>
&lt;p>Redis 客户端可以订阅任意数量的频道。&lt;/p>
&lt;h2 id="发布和订阅">发布和订阅
&lt;a class="header-anchor" href="#%e5%8f%91%e5%b8%83%e5%92%8c%e8%ae%a2%e9%98%85">&lt;/a>
&lt;/h2>&lt;p>1、客户端可以订阅频道如下图&lt;/p>
&lt;p>&lt;img src="https://daemon365.dev/imgs/img-lazy-loading.gif" data-src="https://daemon365.dev/images/96a0c4ca-666f-475e-8dd0-bfbd37f4dbb6.png" alt="" />&lt;/p>
&lt;p>2、当给这个频道发布消息后，消息就会发送给订阅的客户端&lt;/p></description></item><item><title>SQL查询语句执行流程</title><link>https://daemon365.dev/post/database/sql_query_statement_execution_process/</link><pubDate>Thu, 21 May 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/database/sql_query_statement_execution_process/</guid><description>&lt;h2 id="msyql执行流程">msyql执行流程
&lt;a class="header-anchor" href="#msyql%e6%89%a7%e8%a1%8c%e6%b5%81%e7%a8%8b">&lt;/a>
&lt;/h2>&lt;p>你有个最简单的表，表里只有一个 ID 字段，在执行下面这个查询语句时：：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">select&lt;/span> &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">from&lt;/span> T &lt;span style="color:#66d9ef">where&lt;/span> ID&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">10&lt;/span>&lt;span style="color:#960050;background-color:#1e0010">；&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们看到的只是输入一条语句，返回一个结果，却不知道这条语句在 MySQL 内部的执行过程。&lt;/p></description></item><item><title>mysql索引</title><link>https://daemon365.dev/post/database/mysql_index/</link><pubDate>Mon, 20 Apr 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/database/mysql_index/</guid><description>&lt;h2 id="什么是索引">什么是索引
&lt;a class="header-anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%b4%a2%e5%bc%95">&lt;/a>
&lt;/h2>&lt;p>一般的应用系统，都是读多写少。而且插入操作和一般的更新操作很少出现性能问题（因为有redo log锁cache缓存）。在生产环境中，我们遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，因此对查询语句的优化显然是重中之重。说起加速查询，就不得不提到索引了。索引的核心思想就是&lt;strong>加速查询&lt;/strong>。&lt;/p></description></item><item><title>mysql事务</title><link>https://daemon365.dev/post/database/mysql_transaction/</link><pubDate>Fri, 03 Apr 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/database/mysql_transaction/</guid><description>&lt;h2 id="事务是什么">事务是什么
&lt;a class="header-anchor" href="#%e4%ba%8b%e5%8a%a1%e6%98%af%e4%bb%80%e4%b9%88">&lt;/a>
&lt;/h2>&lt;p>&lt;strong>事务就是指逻辑上的一组SQL语句操作，组成这组操作的各个SQL语句，执行时要么全成功要么全失败。&lt;/strong>&lt;/p>
&lt;p>在 MySQL 中，事务支持是在引擎层实现的。MySQL 是一个支持多引擎的系统，但并不是所有的引擎都支持事务。&lt;/p></description></item><item><title>mysql 锁</title><link>https://daemon365.dev/post/database/mysql_lock/</link><pubDate>Thu, 02 Apr 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/database/mysql_lock/</guid><description>&lt;h2 id="mysql中的锁">MySQL中的锁
&lt;a class="header-anchor" href="#mysql%e4%b8%ad%e7%9a%84%e9%94%81">&lt;/a>
&lt;/h2>&lt;p>数据库锁设计的初衷是处理并发问题。作为多用户共享的资源，当出现并发访问的时候，数据库需要合理地控制资源的访问规则。而锁就是用来实现这些访问规则的重要数据结构。&lt;/p></description></item><item><title>msyql redo log和binlog</title><link>https://daemon365.dev/post/database/msyql_redo_log_and_binlog/</link><pubDate>Wed, 01 Apr 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/database/msyql_redo_log_and_binlog/</guid><description>&lt;h2 id="更新语句执行流程">更新语句执行流程
&lt;a class="header-anchor" href="#%e6%9b%b4%e6%96%b0%e8%af%ad%e5%8f%a5%e6%89%a7%e8%a1%8c%e6%b5%81%e7%a8%8b">&lt;/a>
&lt;/h2>&lt;p>下面是这个表的创建语句，这个表有一个主键 ID 和一个整型字段 c：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">create&lt;/span> &lt;span style="color:#66d9ef">table&lt;/span> T(ID int &lt;span style="color:#66d9ef">primary&lt;/span> &lt;span style="color:#66d9ef">key&lt;/span>, &lt;span style="color:#66d9ef">c&lt;/span> int);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果要将 ID=2 这一行的值加 1，SQL 语句就会这么写：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">update&lt;/span> T &lt;span style="color:#66d9ef">set&lt;/span> &lt;span style="color:#66d9ef">c&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">c&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#66d9ef">where&lt;/span> ID&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前面我有跟你介绍过 SQL 语句基本的执行链路，这里我再把那张图拿过来，你也可以先简单看看这个图回顾下。首先，可以确定的说，查询语句的那一套流程，更新语句也是同样会走一遍。&lt;/p></description></item><item><title>MySQL基础数据类型</title><link>https://daemon365.dev/post/database/mysql_basic_data_types/</link><pubDate>Tue, 31 Mar 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/database/mysql_basic_data_types/</guid><description>&lt;h2 id="数值类型">数值类型
&lt;a class="header-anchor" href="#%e6%95%b0%e5%80%bc%e7%b1%bb%e5%9e%8b">&lt;/a>
&lt;/h2>&lt;p>MySQL支持所有标准SQL数值数据类型。&lt;/p>
&lt;p>这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。&lt;/p></description></item><item><title>MySQL数据完整性约束</title><link>https://daemon365.dev/post/database/mysql_data_integrity_constraints/</link><pubDate>Tue, 31 Mar 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/database/mysql_data_integrity_constraints/</guid><description>&lt;h2 id="主键约束">主键约束
&lt;a class="header-anchor" href="#%e4%b8%bb%e9%94%ae%e7%ba%a6%e6%9d%9f">&lt;/a>
&lt;/h2>&lt;p>主键可以是表中的某一列，也可以是表中的多个列所构成的一个组合；其中，由多个列组合而成的主键也称为复合主键。在MySQL中，主键列必须遵守以下规则。&lt;/p></description></item><item><title>redis持久化</title><link>https://daemon365.dev/post/database/redis_persistence/</link><pubDate>Sat, 21 Mar 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/database/redis_persistence/</guid><description>&lt;p>Redis是一种内存型数据库，一旦服务器进程退出，数据库的数据就会丢失，为了解决这个问题，Redis提供了两种持久化的方案，将内存中的数据保存到磁盘中，避免数据的丢失。&lt;/p></description></item><item><title>redis基础</title><link>https://daemon365.dev/post/database/redis_basics/</link><pubDate>Fri, 20 Mar 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/database/redis_basics/</guid><description>&lt;h2 id="redis介绍">redis介绍
&lt;a class="header-anchor" href="#redis%e4%bb%8b%e7%bb%8d">&lt;/a>
&lt;/h2>&lt;p>Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。&lt;/p>
&lt;p>Redis 与其他 key - value 缓存产品有以下三个特点：&lt;/p>
&lt;ul>
&lt;li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。&lt;/li>
&lt;li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。&lt;/li>
&lt;li>Redis支持数据的备份，即master-slave模式的数据备份。&lt;/li>
&lt;/ul>
&lt;h3 id="redis的安装">redis的安装
&lt;a class="header-anchor" href="#redis%e7%9a%84%e5%ae%89%e8%a3%85">&lt;/a>
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>brew install redis&lt;span style="color:#f92672">(&lt;/span>mac&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>yum install redis&lt;span style="color:#f92672">(&lt;/span>centos&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>apt-get install redis&lt;span style="color:#f92672">(&lt;/span>ubuntu&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="redis的命令网站">redis的命令网站
&lt;a class="header-anchor" href="#redis%e7%9a%84%e5%91%bd%e4%bb%a4%e7%bd%91%e7%ab%99">&lt;/a>
&lt;/h2>&lt;p>
&lt;a href="http://doc.redisfans.com/" title="Redis 命令参考 — Redis 命令参考 (redisfans.com)" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 Redis 命令参考 — Redis 命令参考 (redisfans.com)
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>&lt;/p></description></item></channel></rss>