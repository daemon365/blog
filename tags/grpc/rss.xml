<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Grpc on Daemon</title><link>https://daemon365.dev/tags/grpc/</link><description>Recent content in Grpc on Daemon</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Sun, 25 Dec 2022 00:00:00 +0800</lastBuildDate><atom:link href="https://daemon365.dev/tags/grpc/rss.xml" rel="self" type="application/rss+xml"/><item><title>隔离</title><link>https://daemon365.dev/post/microservice/isolation/</link><pubDate>Sun, 25 Dec 2022 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/microservice/isolation/</guid><description>&lt;h2 id="什么是隔离">什么是隔离？
&lt;a class="header-anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e9%9a%94%e7%a6%bb">&lt;/a>
&lt;/h2>&lt;p>隔离，本质上是对系统或资源进行分割，从而实现当系统发生故障时能限定传播范围和影响范围，即发生故障后只有出问题的服务不可用，保证其他服务仍然可用。&lt;/p></description></item><item><title>限流</title><link>https://daemon365.dev/post/microservice/current_limitation/</link><pubDate>Sat, 24 Dec 2022 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/microservice/current_limitation/</guid><description>&lt;h2 id="令牌桶算法">令牌桶算法
&lt;a class="header-anchor" href="#%e4%bb%a4%e7%89%8c%e6%a1%b6%e7%ae%97%e6%b3%95">&lt;/a>
&lt;/h2>&lt;p>是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。令牌桶算法的描述如下：&lt;/p>
&lt;ul>
&lt;li>假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌。&lt;/li>
&lt;li>桶中最多存放 b 个令牌，当桶满时，新添加的令牌被丢弃或拒绝。&lt;/li>
&lt;li>当一个 n 个字节大小的数据包到达，将从桶中删除n 个令牌，接着数据包被发送到网络上。&lt;/li>
&lt;li>如果桶中的令牌不足 n 个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。&lt;/li>
&lt;/ul>
&lt;p>令牌桶速率限制算法: &lt;code>golang.org/x/time/rate&lt;/code>&lt;/p></description></item><item><title>超时控制</title><link>https://daemon365.dev/post/microservice/timeout_control/</link><pubDate>Fri, 23 Dec 2022 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/microservice/timeout_control/</guid><description>&lt;h2 id="什么是超时控制">什么是超时控制？
&lt;a class="header-anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%b6%85%e6%97%b6%e6%8e%a7%e5%88%b6">&lt;/a>
&lt;/h2>&lt;p>超时控制，使我们的服务之间调用可以快速抛错。比如API接口设置1s超时API调用A服务用了500ms，服务A调用和服务B用了600ms，n那么现在已经超时，还要调用服务C等等，再返回超时错误吗？这回事使服务C后面的链路做了无用功，浪费服务器资源。&lt;/p></description></item><item><title>grpc服务发现与负载均衡</title><link>https://daemon365.dev/post/microservice/grpc_service_discovery_and_load_balancing/</link><pubDate>Sun, 20 Dec 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/microservice/grpc_service_discovery_and_load_balancing/</guid><description>&lt;h2 id="前言">前言
&lt;a class="header-anchor" href="#%e5%89%8d%e8%a8%80">&lt;/a>
&lt;/h2>&lt;p>   在后台服务开发中，高可用性是构建中核心且重要的一环。服务发现（Service discovery）和负载均衡（Load Balance）一直都是我关注的话题。今天来谈一下我在实际中是如何理解及落地的。&lt;/p></description></item><item><title>grpc基础</title><link>https://daemon365.dev/post/microservice/grpc_basics/</link><pubDate>Thu, 10 Dec 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/microservice/grpc_basics/</guid><description>&lt;h2 id="rpc-框架原理">RPC 框架原理
&lt;a class="header-anchor" href="#rpc-%e6%a1%86%e6%9e%b6%e5%8e%9f%e7%90%86">&lt;/a>
&lt;/h2>&lt;p>RPC 框架的目标就是让远程服务调用更加简单、透明，RPC 框架负责屏蔽底层的传输方式（TCP 或者 UDP）、序列化方式（XML/Json/ 二进制）和通信细节。服务调用者可以像调用本地接口一样调用远程的服务提供者，而不需要关心底层通信细节和调用过程。&lt;/p></description></item></channel></rss>