<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>源码分析 on Daemon</title><link>https://daemon365.dev/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link><description>Recent content in 源码分析 on Daemon</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Sat, 15 Jun 2024 16:14:00 +0800</lastBuildDate><atom:link href="https://daemon365.dev/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/rss.xml" rel="self" type="application/rss+xml"/><item><title>boltdb 原理</title><link>https://daemon365.dev/post/cloud/boltdb_principles/</link><pubDate>Sat, 15 Jun 2024 16:14:00 +0800</pubDate><guid>https://daemon365.dev/post/cloud/boltdb_principles/</guid><description>&lt;h2 id="简介">简介
&lt;a class="header-anchor" href="#%e7%ae%80%e4%bb%8b">&lt;/a>
&lt;/h2>&lt;p>介绍及简单使用：https://www.cnblogs.com/daemon365/p/17690167.html
源码地址：https://github.com/etcd-io/bbolt&lt;/p></description></item><item><title>kubelet 原理分析</title><link>https://daemon365.dev/post/cloud/analysis_of_kubelet_principles/</link><pubDate>Wed, 01 May 2024 12:40:00 +0800</pubDate><guid>https://daemon365.dev/post/cloud/analysis_of_kubelet_principles/</guid><description>&lt;h2 id="reference">Reference
&lt;a class="header-anchor" href="#reference">&lt;/a>
&lt;/h2>&lt;ul>
&lt;li>
&lt;a href="https://atbug.com/kubelet-source-code-analysis/" title="https://atbug.com/kubelet-source-code-analysis/" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 https://atbug.com/kubelet-source-code-analysis/
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="kubelet-简介">kubelet 简介
&lt;a class="header-anchor" href="#kubelet-%e7%ae%80%e4%bb%8b">&lt;/a>
&lt;/h2>&lt;p>kubernetes 分为控制面和数据面，kubelet 就是数据面最主要的组件，在每个节点上启动，主要负责容器的创建、启停、监控、日志收集等工作。它是一个在每个集群节点上运行的代理，负责确保节点上的容器根据PodSpec（Pod定义文件）正确运行。&lt;/p></description></item><item><title>容器启动流程（containerd 和 runc）</title><link>https://daemon365.dev/post/cloud/container_startup_process_containerd_and_runc/</link><pubDate>Thu, 07 Dec 2023 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/cloud/container_startup_process_containerd_and_runc/</guid><description>&lt;h2 id="启动流程">启动流程
&lt;a class="header-anchor" href="#%e5%90%af%e5%8a%a8%e6%b5%81%e7%a8%8b">&lt;/a>
&lt;/h2>&lt;p>containerd 作为一个 api 服务，提供了一系列的接口供外部调用，比如创建容器、删除容器、创建镜像、删除镜像等等。使用 docker 和 ctr 等工具，都是通过调用 containerd 的 api 来实现的。
kubelet 通过 cri 调用 containerd 和这些不一样，后续我会介绍到。&lt;/p></description></item><item><title>kratos http原理</title><link>https://daemon365.dev/post/kratos/kratos_http_principle/</link><pubDate>Thu, 29 Jun 2023 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/kratos/kratos_http_principle/</guid><description>&lt;h2 id="概念">概念
&lt;a class="header-anchor" href="#%e6%a6%82%e5%bf%b5">&lt;/a>
&lt;/h2>&lt;p>
&lt;a href="https://github.com/go-kratos/kratos" title="kratos" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 kratos
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a> 为了使http协议的逻辑代码和grpc的逻辑代码使用同一份，选择了基于protobuf的IDL文件使用proto插件生成辅助代码的方式。&lt;/p></description></item><item><title>从kratos分析breaker熔断器源码实现</title><link>https://daemon365.dev/post/kratos/analyzing_the_breaker_fuse_source_code_implementation_from_kratos/</link><pubDate>Sat, 04 Sep 2021 17:55:01 +0800</pubDate><guid>https://daemon365.dev/post/kratos/analyzing_the_breaker_fuse_source_code_implementation_from_kratos/</guid><description>&lt;h2 id="为什么要用熔断">为什么要用熔断
&lt;a class="header-anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8%e7%86%94%e6%96%ad">&lt;/a>
&lt;/h2>&lt;p>前面我们讲过限流保证服务的可用性，不被突如其来的流量打爆。但是两种情况是限流解决不了的。&lt;/p>
&lt;ol>
&lt;li>如果我们服务只能处理1000QPS，但是有10wQPS打过来，服务还是会炸。因为拒绝请求也需要成本。&lt;/li>
&lt;li>服务但是io型的，会把mysql，redis，mq等中间件打挂。&lt;/li>
&lt;/ol>
&lt;p>所以，我们遵循一个思路，可不可以client端在失败的多的时候就不调用了，直接返回错误呢？&lt;/p></description></item><item><title>从kratos分析BBR限流源码实现</title><link>https://daemon365.dev/post/kratos/analyzing_the_implementation_of_bbr_current_limiting_source_code_from_kratos/</link><pubDate>Sat, 04 Sep 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/kratos/analyzing_the_implementation_of_bbr_current_limiting_source_code_from_kratos/</guid><description>&lt;h2 id="什么是自适应限流">什么是自适应限流
&lt;a class="header-anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%87%aa%e9%80%82%e5%ba%94%e9%99%90%e6%b5%81">&lt;/a>
&lt;/h2>&lt;p>自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。&lt;/p></description></item><item><title>golang map实现原理</title><link>https://daemon365.dev/post/go/golang_map_implementation_principle/</link><pubDate>Sat, 22 May 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golang_map_implementation_principle/</guid><description>&lt;p>这篇文章主要讲 map 的赋值、删除、查询、扩容的具体执行过程，仍然是从底层的角度展开。结合源码，看完本文一定会彻底明白 map 底层原理。&lt;/p>
&lt;p>我要说明的是，这里对 map 的基本用法涉及比较少，我相信可以通过阅读其他入门书籍了解。本文的内容比较深入，但是由于我画了各种图，我相信很容易看懂。&lt;/p></description></item><item><title>golang channel原理</title><link>https://daemon365.dev/post/go/golang_channel_principle/</link><pubDate>Sun, 21 Feb 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golang_channel_principle/</guid><description>&lt;h2 id="channel介绍">channel介绍
&lt;a class="header-anchor" href="#channel%e4%bb%8b%e7%bb%8d">&lt;/a>
&lt;/h2>&lt;p>channel一个类型管道，通过它可以在goroutine之间发送和接收消息。它是Golang在语言层面提供的goroutine间的通信方式。&lt;/p></description></item><item><title>golang web源码解析</title><link>https://daemon365.dev/post/go/golang_web_source_code_analysis/</link><pubDate>Sat, 21 Mar 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golang_web_source_code_analysis/</guid><description>&lt;h2 id="go的web工作原理">Go的web工作原理
&lt;a class="header-anchor" href="#go%e7%9a%84web%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86">&lt;/a>
&lt;/h2>&lt;p>在Go中使用及其简单的代码即可开启一个web服务。如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//开启web服务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">HandleFunc&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">sayHello&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">ListenAndServe&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;:9090&amp;#34;&lt;/span>,&lt;span style="color:#66d9ef">nil&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span>&lt;span style="color:#f92672">!=&lt;/span>&lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Fatal&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ListenAndServer:&amp;#34;&lt;/span>,&lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">sayHello&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">ResponseWriter&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Request&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">ParseForm&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;path&amp;#34;&lt;/span>,&lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">URL&lt;/span>.&lt;span style="color:#a6e22e">Path&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;scheme&amp;#34;&lt;/span>,&lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">URL&lt;/span>.&lt;span style="color:#a6e22e">Scheme&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Fprintf&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Hello Guest!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在使用&lt;code>ListenAndServe&lt;/code>这个方法时，系统就会给我们指派一个路由器，&lt;code>DefaultServeMux&lt;/code>是系统默认使用的路由器，如果&lt;code>ListenAndServe&lt;/code>这个方法的第2个参数传入nil，系统就会默认使用&lt;code>DefaultServeMux&lt;/code>。当然，这里也可以传入自定义的路由器。&lt;/p></description></item></channel></rss>