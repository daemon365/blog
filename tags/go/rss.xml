<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on Daemon</title><link>https://daemon365.dev/tags/go/</link><description>Recent content in Go on Daemon</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Mon, 25 Sep 2023 00:00:00 +0800</lastBuildDate><atom:link href="https://daemon365.dev/tags/go/rss.xml" rel="self" type="application/rss+xml"/><item><title>行为模式</title><link>https://daemon365.dev/post/go/behavioral_patterns/</link><pubDate>Mon, 25 Sep 2023 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/behavioral_patterns/</guid><description>&lt;h2 id="责任链模式">责任链模式
&lt;a class="header-anchor" href="#%e8%b4%a3%e4%bb%bb%e9%93%be%e6%a8%a1%e5%bc%8f">&lt;/a>
&lt;/h2>&lt;p>&lt;strong>责任链模式&lt;/strong>是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。比如 &lt;code>kratos&lt;/code>,&lt;code>gin&lt;/code>等开源库的中间件实现。&lt;/p></description></item><item><title>结构型模式</title><link>https://daemon365.dev/post/go/structural_patterns/</link><pubDate>Sun, 24 Sep 2023 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/structural_patterns/</guid><description>&lt;h2 id="适配器模式">适配器模式
&lt;a class="header-anchor" href="#%e9%80%82%e9%85%8d%e5%99%a8%e6%a8%a1%e5%bc%8f">&lt;/a>
&lt;/h2>&lt;p>适配器模式用于转换一种接口适配另一种接口。比如，现在有个借口是对&lt;code>json&lt;/code>字符串进行分析等，现在有一些&lt;code>yaml&lt;/code>文件也要分析，这时候我我们就应该给&lt;code>yaml&lt;/code>字符串就个适配器，转换成&lt;code>json&lt;/code>字符串，然后就行分析。&lt;/p></description></item><item><title>创建者模式</title><link>https://daemon365.dev/post/go/creator_mode/</link><pubDate>Sat, 23 Sep 2023 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/creator_mode/</guid><description>&lt;h2 id="单例模式">单例模式
&lt;a class="header-anchor" href="#%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f">&lt;/a>
&lt;/h2>&lt;h3 id="为什么要用单例模式">为什么要用单例模式
&lt;a class="header-anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f">&lt;/a>
&lt;/h3>&lt;p>&lt;strong>保证一个对象只有一个实例&lt;/strong> ，减少内存开销。比如一些可以复用一个连接的网络，比如&lt;code>http2 client&lt;/code>等，而且可以减少网络开销。&lt;/p>
&lt;h3 id="为什么不用个全局变量控制">为什么不用个全局变量控制
&lt;a class="header-anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e7%94%a8%e4%b8%aa%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e6%8e%a7%e5%88%b6">&lt;/a>
&lt;/h3>&lt;p>因为任何代码都有可能覆盖掉那些变量的内容， 从而引发程序崩溃。&lt;/p></description></item><item><title>kratos http原理</title><link>https://daemon365.dev/post/kratos/kratos_http_principle/</link><pubDate>Thu, 29 Jun 2023 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/kratos/kratos_http_principle/</guid><description>&lt;h2 id="概念">概念
&lt;a class="header-anchor" href="#%e6%a6%82%e5%bf%b5">&lt;/a>
&lt;/h2>&lt;p>
&lt;a href="https://github.com/go-kratos/kratos" title="kratos" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 kratos
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a> 为了使http协议的逻辑代码和grpc的逻辑代码使用同一份，选择了基于protobuf的IDL文件使用proto插件生成辅助代码的方式。&lt;/p></description></item><item><title>隔离</title><link>https://daemon365.dev/post/microservice/isolation/</link><pubDate>Sun, 25 Dec 2022 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/microservice/isolation/</guid><description>&lt;h2 id="什么是隔离">什么是隔离？
&lt;a class="header-anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e9%9a%94%e7%a6%bb">&lt;/a>
&lt;/h2>&lt;p>隔离，本质上是对系统或资源进行分割，从而实现当系统发生故障时能限定传播范围和影响范围，即发生故障后只有出问题的服务不可用，保证其他服务仍然可用。&lt;/p></description></item><item><title>限流</title><link>https://daemon365.dev/post/microservice/current_limitation/</link><pubDate>Sat, 24 Dec 2022 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/microservice/current_limitation/</guid><description>&lt;h2 id="令牌桶算法">令牌桶算法
&lt;a class="header-anchor" href="#%e4%bb%a4%e7%89%8c%e6%a1%b6%e7%ae%97%e6%b3%95">&lt;/a>
&lt;/h2>&lt;p>是一个存放固定容量令牌的桶，按照固定速率往桶里添加令牌。令牌桶算法的描述如下：&lt;/p>
&lt;ul>
&lt;li>假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌。&lt;/li>
&lt;li>桶中最多存放 b 个令牌，当桶满时，新添加的令牌被丢弃或拒绝。&lt;/li>
&lt;li>当一个 n 个字节大小的数据包到达，将从桶中删除n 个令牌，接着数据包被发送到网络上。&lt;/li>
&lt;li>如果桶中的令牌不足 n 个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。&lt;/li>
&lt;/ul>
&lt;p>令牌桶速率限制算法: &lt;code>golang.org/x/time/rate&lt;/code>&lt;/p></description></item><item><title>超时控制</title><link>https://daemon365.dev/post/microservice/timeout_control/</link><pubDate>Fri, 23 Dec 2022 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/microservice/timeout_control/</guid><description>&lt;h2 id="什么是超时控制">什么是超时控制？
&lt;a class="header-anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%b6%85%e6%97%b6%e6%8e%a7%e5%88%b6">&lt;/a>
&lt;/h2>&lt;p>超时控制，使我们的服务之间调用可以快速抛错。比如API接口设置1s超时API调用A服务用了500ms，服务A调用和服务B用了600ms，n那么现在已经超时，还要调用服务C等等，再返回超时错误吗？这回事使服务C后面的链路做了无用功，浪费服务器资源。&lt;/p></description></item><item><title>Go命令行工具cobra</title><link>https://daemon365.dev/post/go/go_command_line_tool_cobra/</link><pubDate>Wed, 21 Dec 2022 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/go_command_line_tool_cobra/</guid><description>&lt;h2 id="关于">关于
&lt;a class="header-anchor" href="#%e5%85%b3%e4%ba%8e">&lt;/a>
&lt;/h2>&lt;p>Cobra 是 Go 的 CLI 框架。它包含一个用于创建功能强大的现代 CLI 应用程序的库，以及一个用于快速生成基于 Cobra 的应用程序和命令文件的工具。&lt;/p>
&lt;p>Cobra 由 Go 项目成员和 hugo 作者 
&lt;a href="https://github.com/spf13" title="spf13" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 spf13
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a> 创建，已经被许多流行的 Go 项目采用，比如 kubernetes、docker等&lt;/p></description></item><item><title>Go工程化 - 依赖注入</title><link>https://daemon365.dev/post/kratos/go_engineering___dependency_injection/</link><pubDate>Thu, 30 Sep 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/kratos/go_engineering___dependency_injection/</guid><description>&lt;p>我们在微服务框架
&lt;a href="https://github.com/go-kratos/kratos" title="kratos v2" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 kratos v2
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>的默认项目模板中
&lt;a href="https://github.com/go-kratos/kratos-layout" title="kratos-layout" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 kratos-layout
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>使用了
&lt;a href="https://github.com/google/wire" title="google/wire" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 google/wire
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>进行依赖注入，也建议开发者在维护项目时使用该工具。&lt;/p>
&lt;p>wire 乍看起来比较违反直觉，导致很多同学不理解为什么要用或不清楚如何用（也包括曾经的我），本文来帮助大家理解 wire 的使用。&lt;/p></description></item><item><title>kratos v2版本命令行工具使用</title><link>https://daemon365.dev/post/kratos/kratos_v2_command_line_tool_usage/</link><pubDate>Sun, 12 Sep 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/kratos/kratos_v2_command_line_tool_usage/</guid><description>&lt;h2 id="使用">使用
&lt;a class="header-anchor" href="#%e4%bd%bf%e7%94%a8">&lt;/a>
&lt;/h2>&lt;h3 id="下载">下载
&lt;a class="header-anchor" href="#%e4%b8%8b%e8%bd%bd">&lt;/a>
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>go install github.com/go-kratos/kratos/cmd/kratos/v2@latest
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看是否安装成功&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kratos -v
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kratos version v2.1.3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="升级">升级
&lt;a class="header-anchor" href="#%e5%8d%87%e7%ba%a7">&lt;/a>
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>kratos upgrade
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="查看帮助">查看帮助
&lt;a class="header-anchor" href="#%e6%9f%a5%e7%9c%8b%e5%b8%ae%e5%8a%a9">&lt;/a>
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">kratos&lt;/span> &lt;span style="color:#f92672">--&lt;/span>&lt;span style="color:#a6e22e">help&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-gdscript3" data-lang="gdscript3">&lt;span style="display:flex;">&lt;span>Kratos: An elegant toolkit &lt;span style="color:#66d9ef">for&lt;/span> Go microservices&lt;span style="color:#f92672">.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Usage:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> kratos [command]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Available Commands:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> changelog Get a kratos change log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> completion generate the autocompletion script &lt;span style="color:#66d9ef">for&lt;/span> the specified shell
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> help Help about any command
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> new Create a service template
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> proto Generate the proto files
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> run Run project
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> upgrade Upgrade the kratos tools
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Flags:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span>h, &lt;span style="color:#f92672">--&lt;/span>help help &lt;span style="color:#66d9ef">for&lt;/span> kratos
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">-&lt;/span>v, &lt;span style="color:#f92672">--&lt;/span>version version &lt;span style="color:#66d9ef">for&lt;/span> kratos
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Use &lt;span style="color:#e6db74">&amp;#34;kratos [command] --help&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> more information about a command&lt;span style="color:#f92672">.&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="new命令">new命令
&lt;a class="header-anchor" href="#new%e5%91%bd%e4%bb%a4">&lt;/a>
&lt;/h2>&lt;p>kratos new 命令为创建一个kratos项目&lt;/p></description></item><item><title>从kratos分析breaker熔断器源码实现</title><link>https://daemon365.dev/post/kratos/analyzing_the_breaker_fuse_source_code_implementation_from_kratos/</link><pubDate>Sat, 04 Sep 2021 17:55:01 +0800</pubDate><guid>https://daemon365.dev/post/kratos/analyzing_the_breaker_fuse_source_code_implementation_from_kratos/</guid><description>&lt;h2 id="为什么要用熔断">为什么要用熔断
&lt;a class="header-anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8%e7%86%94%e6%96%ad">&lt;/a>
&lt;/h2>&lt;p>前面我们讲过限流保证服务的可用性，不被突如其来的流量打爆。但是两种情况是限流解决不了的。&lt;/p>
&lt;ol>
&lt;li>如果我们服务只能处理1000QPS，但是有10wQPS打过来，服务还是会炸。因为拒绝请求也需要成本。&lt;/li>
&lt;li>服务但是io型的，会把mysql，redis，mq等中间件打挂。&lt;/li>
&lt;/ol>
&lt;p>所以，我们遵循一个思路，可不可以client端在失败的多的时候就不调用了，直接返回错误呢？&lt;/p></description></item><item><title>从kratos分析BBR限流源码实现</title><link>https://daemon365.dev/post/kratos/analyzing_the_implementation_of_bbr_current_limiting_source_code_from_kratos/</link><pubDate>Sat, 04 Sep 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/kratos/analyzing_the_implementation_of_bbr_current_limiting_source_code_from_kratos/</guid><description>&lt;h2 id="什么是自适应限流">什么是自适应限流
&lt;a class="header-anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%87%aa%e9%80%82%e5%ba%94%e9%99%90%e6%b5%81">&lt;/a>
&lt;/h2>&lt;p>自适应限流从整体维度对应用入口流量进行控制，结合应用的 Load、CPU 使用率、总体平均 RT、入口 QPS 和并发线程数等几个维度的监控指标，通过自适应的流控策略，让系统的入口流量和系统的负载达到一个平衡，让系统尽可能跑在最大吞吐量的同时保证系统整体的稳定性。&lt;/p></description></item><item><title>Kratos漫游指南 1 - 概览</title><link>https://daemon365.dev/post/kratos/the_hitchhikers_guide_to_kratos_1___overview/</link><pubDate>Thu, 02 Sep 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/kratos/the_hitchhikers_guide_to_kratos_1___overview/</guid><description>&lt;p>您好，地球人，欢迎来到Kratos漫游指南。&lt;/p>
&lt;p>对于刚开始研究Kratos框架的开发者来说，目前的文档有些零散，这与我们的模块化设计有一些关系，不过Don&amp;rsquo;t panic，从这篇文章开始，我将试图打破这一现状，漫游指南系列将循序渐进地介绍Kratos框架，理顺框架的使用思路，使您更快上手Kratos。&lt;/p></description></item><item><title>基于 OpenTelemetry 的链路追踪</title><link>https://daemon365.dev/post/kratos/link_tracing_based_on_opentelemetry/</link><pubDate>Mon, 23 Aug 2021 18:11:50 +0800</pubDate><guid>https://daemon365.dev/post/kratos/link_tracing_based_on_opentelemetry/</guid><description>&lt;h2 id="链路追踪的前世今生">链路追踪的前世今生
&lt;a class="header-anchor" href="#%e9%93%be%e8%b7%af%e8%bf%bd%e8%b8%aa%e7%9a%84%e5%89%8d%e4%b8%96%e4%bb%8a%e7%94%9f">&lt;/a>
&lt;/h2>&lt;blockquote>
&lt;p>分布式跟踪（也称为分布式请求跟踪）是一种用于分析和监控应用程序的方法，尤其是使用微服务架构构建的应用程序。分布式跟踪有助于精确定位故障发生的位置以及导致性能差的原因。&lt;/p></description></item><item><title>通过 layout 探索 kratos 运行原理</title><link>https://daemon365.dev/post/kratos/explore_the_working_principle_of_kratos_through_layout/</link><pubDate>Fri, 20 Aug 2021 18:11:50 +0800</pubDate><guid>https://daemon365.dev/post/kratos/explore_the_working_principle_of_kratos_through_layout/</guid><description>&lt;h2 id="创建项目">创建项目
&lt;a class="header-anchor" href="#%e5%88%9b%e5%bb%ba%e9%a1%b9%e7%9b%ae">&lt;/a>
&lt;/h2>&lt;p>首先需要安装好对应的依赖环境，以及工具：&lt;/p>
&lt;ol>
&lt;li>go
&lt;ul>
&lt;li>
&lt;a href="https://studygolang.com/dl" title="下载" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 下载
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>protoc
&lt;ul>
&lt;li>&lt;code>go install google.golang.org/protobuf/cmd/protoc-gen-go@latest&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>protoc-gen-go
&lt;ul>
&lt;li>&lt;code>go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 创建项目模板&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kratos new helloworld
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cd helloworld
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 拉取项目依赖&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>go mod download
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 生成proto模板&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kratos proto add api/helloworld/helloworld.proto
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 生成proto源码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kratos proto client api/helloworld/helloworld.proto
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 生成server模板&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kratos proto server api/helloworld/helloworld.proto -t internal/service
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行命令后,会在当前目录下生成一个 service 工程,工程骨架如下,具体的工程骨架说明可以访问 
&lt;a href="https://go-kratos.dev/docs/intro/layout" title="layout" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 layout
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>&lt;/p></description></item><item><title>kratos 日志库的使用姿势</title><link>https://daemon365.dev/post/kratos/how_to_use_the_log_library/</link><pubDate>Thu, 19 Aug 2021 18:11:50 +0800</pubDate><guid>https://daemon365.dev/post/kratos/how_to_use_the_log_library/</guid><description>&lt;h2 id="什么是日志">什么是日志
&lt;a class="header-anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%97%a5%e5%bf%97">&lt;/a>
&lt;/h2>&lt;blockquote>
&lt;p>所谓日志（Log）是指系统所指定对象的某些操作和其操作结果按时间有序的集合。log文件就是日志文件，log文件记录了系统和系统的用户之间交互的信息，是自动捕获人与系统终端之间交互的类型、内容或时间的数据收集方法。&lt;/p></description></item><item><title>golang map实现原理</title><link>https://daemon365.dev/post/go/golang_map_implementation_principle/</link><pubDate>Sat, 22 May 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golang_map_implementation_principle/</guid><description>&lt;p>这篇文章主要讲 map 的赋值、删除、查询、扩容的具体执行过程，仍然是从底层的角度展开。结合源码，看完本文一定会彻底明白 map 底层原理。&lt;/p>
&lt;p>我要说明的是，这里对 map 的基本用法涉及比较少，我相信可以通过阅读其他入门书籍了解。本文的内容比较深入，但是由于我画了各种图，我相信很容易看懂。&lt;/p></description></item><item><title>zap高性能日志</title><link>https://daemon365.dev/post/go/zap_high_performance_log/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/zap_high_performance_log/</guid><description>&lt;h2 id="摘要">摘要
&lt;a class="header-anchor" href="#%e6%91%98%e8%a6%81">&lt;/a>
&lt;/h2>&lt;p>日志在整个工程实践中的重要性不言而喻，在选择日志组件的时候也有多方面的考量。详细、正确和及时的反馈是必不可少的，但是整个性能表现是否也是必要考虑的点呢？在长期的实践中发现有的日志组件对于计算资源的消耗十分巨大，这将导致整个服务成本的居高不下。此文从设计原理深度分析了 zap 的设计与实现上的权衡，也希望整个的选择、考量的过程能给其他的技术团队在开发高性能的 Go 组件时带来一定的借鉴意义。&lt;/p></description></item><item><title>golang channel原理</title><link>https://daemon365.dev/post/go/golang_channel_principle/</link><pubDate>Sun, 21 Feb 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golang_channel_principle/</guid><description>&lt;h2 id="channel介绍">channel介绍
&lt;a class="header-anchor" href="#channel%e4%bb%8b%e7%bb%8d">&lt;/a>
&lt;/h2>&lt;p>channel一个类型管道，通过它可以在goroutine之间发送和接收消息。它是Golang在语言层面提供的goroutine间的通信方式。&lt;/p></description></item><item><title>golang GC 垃圾回收机制</title><link>https://daemon365.dev/post/go/golang_gc_garbage_collection_mechanism/</link><pubDate>Sat, 20 Feb 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golang_gc_garbage_collection_mechanism/</guid><description>&lt;p>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的对象，让出存储器资源，无需程序员手动执行。&lt;/p></description></item><item><title>viper配置管理</title><link>https://daemon365.dev/post/go/viper_configuration_management/</link><pubDate>Sat, 23 Jan 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/viper_configuration_management/</guid><description>&lt;h2 id="安装">安装
&lt;a class="header-anchor" href="#%e5%ae%89%e8%a3%85">&lt;/a>
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>go get github.com/spf13/viper
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="viper支持的功能">viper支持的功能
&lt;a class="header-anchor" href="#viper%e6%94%af%e6%8c%81%e7%9a%84%e5%8a%9f%e8%83%bd">&lt;/a>
&lt;/h2>&lt;p>1、可以设置默认值
2、可以加载多种格式的配置文件，如JSON，TOML，YAML，HCL和Java属性配置文件
3、应用程序运行过程中，保持监听和重新读取配置文件
4、可以从环境变量读取配置
5、可以从远程配置系统读取配置
6、可以读取命令行标志作为配置
7、可以从缓冲区中读取
8、设置显式的值&lt;/p></description></item><item><title>golangHTML标签提取器soup</title><link>https://daemon365.dev/post/go/golanghtml_tag_extractor_soup/</link><pubDate>Tue, 05 Jan 2021 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golanghtml_tag_extractor_soup/</guid><description>&lt;h2 id="什么是soup">什么是soup
&lt;a class="header-anchor" href="#%e4%bb%80%e4%b9%88%e6%98%afsoup">&lt;/a>
&lt;/h2>&lt;p>类似python中beatifulsoup，用于提取html标签提取，多用于爬虫。它可以很好的处理不规范标记并生成剖析树(parse tree)。 它提供简单又常用的导航，搜索以及修改剖析树的操作。利用它我们不在需要编写正则表达式就可以方便的实现网页信息的提取。soup是一个小型的网页提取包，其接口与beauthoulsoup非常相似。&lt;/p></description></item><item><title>thrift的介绍及其使用</title><link>https://daemon365.dev/post/microservice/introduction_and_use_of_thrift/</link><pubDate>Wed, 30 Dec 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/microservice/introduction_and_use_of_thrift/</guid><description>&lt;h2 id="什么是thrift">什么是thrift
&lt;a class="header-anchor" href="#%e4%bb%80%e4%b9%88%e6%98%afthrift">&lt;/a>
&lt;/h2>&lt;p>Thrift是Facebook于2007年开发的跨语言的rpc服框架，提供多语言的编译功能，并提供多种服务器工作模式；用户通过Thrift的IDL（接口定义语言）来描述接口函数及数据类型，然后通过Thrift的编译环境生成各种语言类型的接口文件，用户可以根据自己的需要采用不同的语言开发客户端代码和服务器端代码。&lt;/p></description></item><item><title>grpc服务发现与负载均衡</title><link>https://daemon365.dev/post/microservice/grpc_service_discovery_and_load_balancing/</link><pubDate>Sun, 20 Dec 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/microservice/grpc_service_discovery_and_load_balancing/</guid><description>&lt;h2 id="前言">前言
&lt;a class="header-anchor" href="#%e5%89%8d%e8%a8%80">&lt;/a>
&lt;/h2>&lt;p>   在后台服务开发中，高可用性是构建中核心且重要的一环。服务发现（Service discovery）和负载均衡（Load Balance）一直都是我关注的话题。今天来谈一下我在实际中是如何理解及落地的。&lt;/p></description></item><item><title>grpc基础</title><link>https://daemon365.dev/post/microservice/grpc_basics/</link><pubDate>Thu, 10 Dec 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/microservice/grpc_basics/</guid><description>&lt;h2 id="rpc-框架原理">RPC 框架原理
&lt;a class="header-anchor" href="#rpc-%e6%a1%86%e6%9e%b6%e5%8e%9f%e7%90%86">&lt;/a>
&lt;/h2>&lt;p>RPC 框架的目标就是让远程服务调用更加简单、透明，RPC 框架负责屏蔽底层的传输方式（TCP 或者 UDP）、序列化方式（XML/Json/ 二进制）和通信细节。服务调用者可以像调用本地接口一样调用远程的服务提供者，而不需要关心底层通信细节和调用过程。&lt;/p></description></item><item><title>golang jwt</title><link>https://daemon365.dev/post/go/golang_jwt/</link><pubDate>Wed, 20 May 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golang_jwt/</guid><description>&lt;h2 id="什么是jwt">什么是JWT？
&lt;a class="header-anchor" href="#%e4%bb%80%e4%b9%88%e6%98%afjwt">&lt;/a>
&lt;/h2>&lt;p>JWT全称JSON Web Token是一种跨域认证解决方案，属于一个开放的标准，它规定了一种Token实现方式，目前多用于前后端分离项目和OAuth2.0业务场景下。&lt;/p></description></item><item><title>golang web源码解析</title><link>https://daemon365.dev/post/go/golang_web_source_code_analysis/</link><pubDate>Sat, 21 Mar 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golang_web_source_code_analysis/</guid><description>&lt;h2 id="go的web工作原理">Go的web工作原理
&lt;a class="header-anchor" href="#go%e7%9a%84web%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86">&lt;/a>
&lt;/h2>&lt;p>在Go中使用及其简单的代码即可开启一个web服务。如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//开启web服务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">test&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">HandleFunc&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">sayHello&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">ListenAndServe&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;:9090&amp;#34;&lt;/span>,&lt;span style="color:#66d9ef">nil&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span>&lt;span style="color:#f92672">!=&lt;/span>&lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Fatal&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ListenAndServer:&amp;#34;&lt;/span>,&lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">sayHello&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">ResponseWriter&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Request&lt;/span>){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">ParseForm&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;path&amp;#34;&lt;/span>,&lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">URL&lt;/span>.&lt;span style="color:#a6e22e">Path&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;scheme&amp;#34;&lt;/span>,&lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">URL&lt;/span>.&lt;span style="color:#a6e22e">Scheme&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Fprintf&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Hello Guest!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在使用&lt;code>ListenAndServe&lt;/code>这个方法时，系统就会给我们指派一个路由器，&lt;code>DefaultServeMux&lt;/code>是系统默认使用的路由器，如果&lt;code>ListenAndServe&lt;/code>这个方法的第2个参数传入nil，系统就会默认使用&lt;code>DefaultServeMux&lt;/code>。当然，这里也可以传入自定义的路由器。&lt;/p></description></item><item><title>golang nethttp包</title><link>https://daemon365.dev/post/go/golang_nethttp_package/</link><pubDate>Sat, 11 Jan 2020 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golang_nethttp_package/</guid><description>&lt;h2 id="http协议">http协议
&lt;a class="header-anchor" href="#http%e5%8d%8f%e8%ae%ae">&lt;/a>
&lt;/h2>&lt;p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。&lt;/p></description></item><item><title>nethttp和gin 路由</title><link>https://daemon365.dev/post/go/nethttp_and_gin_routing/</link><pubDate>Mon, 23 Dec 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/nethttp_and_gin_routing/</guid><description>&lt;h2 id="nethttp-路由注册">net/http 路由注册
&lt;a class="header-anchor" href="#nethttp-%e8%b7%af%e7%94%b1%e6%b3%a8%e5%86%8c">&lt;/a>
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">test1&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">HandleFunc&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">ResponseWriter&lt;/span>, &lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">Request&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Fprintf&lt;/span>(&lt;span style="color:#a6e22e">w&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Hello world!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">http&lt;/span>.&lt;span style="color:#a6e22e">ListenAndServe&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;:9001&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">log&lt;/span>.&lt;span style="color:#a6e22e">Fatal&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;ListenAndServer:&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在使用&lt;code>ListenAndServe&lt;/code>这个方法时，系统就会给我们指派一个路由器，&lt;code>DefaultServeMux&lt;/code>是系统默认使用的路由器，如果&lt;code>ListenAndServe&lt;/code>这个方法的第2个参数传入nil，系统就会默认使用&lt;code>DefaultServeMux&lt;/code>。当然，这里也可以传入自定义的路由器。&lt;/p></description></item><item><title>proto buffer</title><link>https://daemon365.dev/post/microservice/protocol_buffer/</link><pubDate>Sun, 01 Dec 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/microservice/protocol_buffer/</guid><description>&lt;p>protobuf是一种高效的数据格式，平台无关、语言无关、可扩展，可用于 RPC 系统和持续数据存储系统。&lt;/p>
&lt;h2 id="protobuf介绍">protobuf介绍
&lt;a class="header-anchor" href="#protobuf%e4%bb%8b%e7%bb%8d">&lt;/a>
&lt;/h2>&lt;p>Protobuf是Protocol Buffer的简称，它是Google公司于2008年开源的一种高效的平台无关、语言无关、可扩展的数据格式，目前Protobuf作为接口规范的描述语言，可以作为Go语言RPC接口的基础工具。&lt;/p></description></item><item><title>go mod</title><link>https://daemon365.dev/post/go/go_mod/</link><pubDate>Tue, 01 Oct 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/go_mod/</guid><description>&lt;p>go module是 Go1.11版本之后官方推出的版本管理工具，并且从Go1.13版本开始，go module将是Go语言默认的依赖管理工具。&lt;/p>
&lt;h2 id="go111module">GO111MODULE
&lt;a class="header-anchor" href="#go111module">&lt;/a>
&lt;/h2>&lt;p>要启用go module支持首先要设置环境变量GO111MODULE，通过它可以开启或关闭模块支持，它有三个可选值：off、on、auto，默认值是auto。&lt;/p></description></item><item><title>golang 模板 htmltemplate与texttemplate</title><link>https://daemon365.dev/post/go/golang_template_htmltemplate_and_texttemplate/</link><pubDate>Sat, 13 Jul 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golang_template_htmltemplate_and_texttemplate/</guid><description>&lt;h2 id="html模板生成">html模板生成:
&lt;a class="header-anchor" href="#html%e6%a8%a1%e6%9d%bf%e7%94%9f%e6%88%90">&lt;/a>
&lt;/h2>&lt;ul>
&lt;li>html/template包实现了数据驱动的模板，用于生成可对抗代码注入的安全HTML输出。它提供了和text/template包相同的接口，Go语言中输出HTML的场景都应使用text/template包。&lt;/li>
&lt;/ul>
&lt;h2 id="模板语法">模板语法
&lt;a class="header-anchor" href="#%e6%a8%a1%e6%9d%bf%e8%af%ad%e6%b3%95">&lt;/a>
&lt;/h2>&lt;h3 id="heading">{{.}}
&lt;a class="header-anchor" href="#heading">&lt;/a>
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>模板语法都包含在{{和}}中间，其中{{.}}中的点表示当前对象。&lt;/p></description></item><item><title>golang 反射</title><link>https://daemon365.dev/post/go/golang_reflection/</link><pubDate>Fri, 12 Jul 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golang_reflection/</guid><description>&lt;h2 id="变量的内在机制">变量的内在机制
&lt;a class="header-anchor" href="#%e5%8f%98%e9%87%8f%e7%9a%84%e5%86%85%e5%9c%a8%e6%9c%ba%e5%88%b6">&lt;/a>
&lt;/h2>&lt;p>Go语言中的变量是分为两部分的:&lt;/p>
&lt;ul>
&lt;li>类型信息：预先定义好的元信息。&lt;/li>
&lt;li>值信息：程序运行过程中可动态变化的。&lt;/li>
&lt;/ul>
&lt;h2 id="反射介绍">反射介绍
&lt;a class="header-anchor" href="#%e5%8f%8d%e5%b0%84%e4%bb%8b%e7%bb%8d">&lt;/a>
&lt;/h2>&lt;p>反射是指在程序运行期对程序本身进行访问和修改的能力。程序在编译时，变量被转换为内存地址，变量名不会被编译器写入到可执行部分。在运行程序时，程序无法获取自身的信息。&lt;/p></description></item><item><title>Gin框架介绍及使用</title><link>https://daemon365.dev/post/go/introduction_and_use_of_gin_framework/</link><pubDate>Sun, 30 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/introduction_and_use_of_gin_framework/</guid><description>&lt;h2 id="gin框架介绍">Gin框架介绍
&lt;a class="header-anchor" href="#gin%e6%a1%86%e6%9e%b6%e4%bb%8b%e7%bb%8d">&lt;/a>
&lt;/h2>&lt;ul>
&lt;li>基于
&lt;a href="https://github.com/julienschmidt/httprouter" title="httprouter" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 httprouter
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>开发的Web框架。&lt;/li>
&lt;li>
&lt;a href="https://gin-gonic.com/zh-cn/docs/" title="中文文档" rel="noopener external nofollow noreferrer" target="_blank" class=" exturl">
 中文文档
 
 &lt;i class="fa fa-external-link-alt">&lt;/i>
 
&lt;/a>，齐全。&lt;/li>
&lt;li>简单易用的轻量级框架。&lt;/li>
&lt;/ul>
&lt;h2 id="gin框架安装">Gin框架安装
&lt;a class="header-anchor" href="#gin%e6%a1%86%e6%9e%b6%e5%ae%89%e8%a3%85">&lt;/a>
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>go get -u github.com/gin-gonic/gin
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>实例:&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#e6db74">&amp;#34;github.com/gin-gonic/gin&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">r&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">gin&lt;/span>.&lt;span style="color:#a6e22e">Default&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">// 创建一个默认的路由引擎
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#75715e">// 也可以用gin.New() gin.Default()多用了日志和panic的recover中间件
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">GET&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;/helloworld&amp;#34;&lt;/span>, &lt;span style="color:#66d9ef">func&lt;/span>(&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">gin&lt;/span>.&lt;span style="color:#a6e22e">Context&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">JSON&lt;/span>(&lt;span style="color:#ae81ff">200&lt;/span>, &lt;span style="color:#a6e22e">gin&lt;/span>.&lt;span style="color:#a6e22e">H&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#75715e">// c.JSON：返回JSON格式的数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>			&lt;span style="color:#e6db74">&amp;#34;msg&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;Hello world!&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">r&lt;/span>.&lt;span style="color:#a6e22e">Run&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;127.0.0.1:8001&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#75715e">// 启动HTTP服务，默认在127.0.0.1:8001启动服务
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;run gin field&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://daemon365.dev/imgs/img-lazy-loading.gif" data-src="https://daemon365.dev/images/a78c08f7-e35f-41f2-bc49-9388ef405408.png" alt="" />&lt;/p></description></item><item><title>goalng包和命令工具</title><link>https://daemon365.dev/post/go/goalng_package_and_command_tools/</link><pubDate>Sat, 29 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/goalng_package_and_command_tools/</guid><description>&lt;h2 id="包简介">包简介
&lt;a class="header-anchor" href="#%e5%8c%85%e7%ae%80%e4%bb%8b">&lt;/a>
&lt;/h2>&lt;p>任何包系统设计的目的都是为了简化大型程序的设计和维护工作，通过将一组相关的特性放进一个独立的单元以便于理解和更新，在每个单元更新的同时保持和程序中其它单元的相对独立性。这种模块化的特性允许每个包可以被其它的不同项目共享和重用，在项目范围内、甚至全球范围统一的分发和复用。&lt;/p></description></item><item><title>golang 单元测试</title><link>https://daemon365.dev/post/go/golang_unit_testing/</link><pubDate>Sat, 29 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golang_unit_testing/</guid><description>&lt;h2 id="go-test">go test
&lt;a class="header-anchor" href="#go-test">&lt;/a>
&lt;/h2>&lt;p>go test命令是一个按照一定的约定和组织来测试代码的程序。在包目录内，所有以_test.go为后缀名的源文件在执行go build时不会被构建成包的一部分，它们是go test测试的一部分。&lt;/p></description></item><item><title>golang context包</title><link>https://daemon365.dev/post/go/golang_context_package/</link><pubDate>Fri, 28 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golang_context_package/</guid><description>&lt;h2 id="go-context标准库">go context标准库
&lt;a class="header-anchor" href="#go-context%e6%a0%87%e5%87%86%e5%ba%93">&lt;/a>
&lt;/h2>&lt;p>context包在Go1.7版本时加入到标准库中。其设计目标是给Golang提供一个标准接口来给其他任务发送取消信号和传递数据。其具体作用为：&lt;/p></description></item><item><title>golang channel</title><link>https://daemon365.dev/post/go/golang_channel/</link><pubDate>Wed, 26 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golang_channel/</guid><description>&lt;h2 id="什么是channel">什么是channel
&lt;a class="header-anchor" href="#%e4%bb%80%e4%b9%88%e6%98%afchannel">&lt;/a>
&lt;/h2>&lt;p>channels 是一种类型安全的消息队列，充当两个 goroutine 之间的管道，将通过它同步的进行任意资源的交换。chan 控制 goroutines 交互的能力从而创建了 Go 同步机制。当创建的 chan 没有容量时，称为无缓冲通道。反过来，使用容量创建的 chan 称为缓冲通道。&lt;/p></description></item><item><title>golang并发</title><link>https://daemon365.dev/post/go/golang_concurrency/</link><pubDate>Wed, 26 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golang_concurrency/</guid><description>&lt;h2 id="goroutine">goroutine
&lt;a class="header-anchor" href="#goroutine">&lt;/a>
&lt;/h2>&lt;p>goroutine是Go并行设计的核心。goroutine说到底其实就是线程，但是它比线程更小，十几个goroutine可能体现在底层就是五六个线程，Go语言内部帮你实现了这些goroutine之间的内存共享。执行goroutine只需极少的栈内存(大概是4~5KB)，当然会根据相应的数据伸缩。也正因为如此，可同时运行成千上万个并发任务。goroutine比thread更易用、更高效、更轻便。&lt;/p></description></item><item><title>go语言文件系统</title><link>https://daemon365.dev/post/go/go_language_file_system/</link><pubDate>Sun, 23 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/go_language_file_system/</guid><description>&lt;h2 id="检测文件是否存在">检测文件是否存在
&lt;a class="header-anchor" href="#%e6%a3%80%e6%b5%8b%e6%96%87%e4%bb%b6%e6%98%af%e5%90%a6%e5%ad%98%e5%9c%a8">&lt;/a>
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//存在返回 true，不存在返回 false
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">fileIfExist&lt;/span>(&lt;span style="color:#a6e22e">filename&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>) &lt;span style="color:#66d9ef">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Stat&lt;/span>(&lt;span style="color:#a6e22e">filename&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">filename&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;is not exist!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">IsNotExist&lt;/span>(&lt;span style="color:#a6e22e">err&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="打开文件">打开文件
&lt;a class="header-anchor" href="#%e6%89%93%e5%bc%80%e6%96%87%e4%bb%b6">&lt;/a>
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">f&lt;/span>, &lt;span style="color:#a6e22e">err&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">os&lt;/span>.&lt;span style="color:#a6e22e">Open&lt;/span>(&lt;span style="color:#a6e22e">filename&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#66d9ef">nil&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#a6e22e">err&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;open&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">filename&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;failed!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">defer&lt;/span> &lt;span style="color:#a6e22e">f&lt;/span>.&lt;span style="color:#a6e22e">Close&lt;/span>()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果文件不存在，就会返回错误，如果存在就以只读的方式打开文件。&lt;/p></description></item><item><title>golang方法</title><link>https://daemon365.dev/post/go/golang_method/</link><pubDate>Sat, 22 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golang_method/</guid><description>&lt;h2 id="方法声明">方法声明
&lt;a class="header-anchor" href="#%e6%96%b9%e6%b3%95%e5%a3%b0%e6%98%8e">&lt;/a>
&lt;/h2>&lt;p>在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> &lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">People&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">age&lt;/span> &lt;span style="color:#66d9ef">uint8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#a6e22e">People&lt;/span>) &lt;span style="color:#a6e22e">SayHello&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">name&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;: hello world&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">age&lt;/span> = &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">p&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">People&lt;/span>{&lt;span style="color:#a6e22e">name&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;zhaohaiyu&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">age&lt;/span>: &lt;span style="color:#ae81ff">18&lt;/span>} 
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">SayHello&lt;/span>() &lt;span style="color:#75715e">// zhaohaiyu : hello world
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Println&lt;/span>(&lt;span style="color:#a6e22e">p&lt;/span>.&lt;span style="color:#a6e22e">age&lt;/span>)	&lt;span style="color:#75715e">//18
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="基于指针对象的方法">基于指针对象的方法
&lt;a class="header-anchor" href="#%e5%9f%ba%e4%ba%8e%e6%8c%87%e9%92%88%e5%af%b9%e8%b1%a1%e7%9a%84%e6%96%b9%e6%b3%95">&lt;/a>
&lt;/h2>&lt;p>当调用一个函数时，会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就需要用到指针了。&lt;/p></description></item><item><title>golang复杂数据结构</title><link>https://daemon365.dev/post/go/golang_complex_data_structure/</link><pubDate>Sat, 22 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golang_complex_data_structure/</guid><description>&lt;h2 id="数组">数组
&lt;a class="header-anchor" href="#%e6%95%b0%e7%bb%84">&lt;/a>
&lt;/h2>&lt;p>**数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。**因为数组的长度是固定的，因此在Go语言中很少直接使用数组。&lt;/p></description></item><item><title>golang函数</title><link>https://daemon365.dev/post/go/golang_function/</link><pubDate>Sat, 22 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golang_function/</guid><description>&lt;h2 id="函数声明">函数声明
&lt;a class="header-anchor" href="#%e5%87%bd%e6%95%b0%e5%a3%b0%e6%98%8e">&lt;/a>
&lt;/h2>&lt;p>&lt;strong>函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">function&lt;/span>&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#a6e22e">name&lt;/span>(&lt;span style="color:#a6e22e">param&lt;/span>&lt;span style="color:#f92672">...&lt;/span>) (&lt;span style="color:#a6e22e">result&lt;/span>&lt;span style="color:#f92672">...&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">body&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>形式参数列表描述了函数的参数名以及参数类型。这些参数作为局部变量，其值由参数调用者提供。返回值列表描述了函数返回值的变量名以及类型。如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值。&lt;/p></description></item><item><title>golang基础结构</title><link>https://daemon365.dev/post/go/golang_infrastructure/</link><pubDate>Sat, 22 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golang_infrastructure/</guid><description>&lt;h2 id="命名">命名
&lt;a class="header-anchor" href="#%e5%91%bd%e5%90%8d">&lt;/a>
&lt;/h2>&lt;p>Go语言中的&lt;strong>函数名&lt;/strong>、&lt;strong>变量名&lt;/strong>、&lt;strong>常量名&lt;/strong>、&lt;strong>类型名&lt;/strong>、&lt;strong>语句标号&lt;/strong>和&lt;strong>包名&lt;/strong>等所有的命名,都遵循一个简单的命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头,后面可以跟任意数量的&lt;strong>字母&lt;/strong>、&lt;strong>数字&lt;/strong>或&lt;strong>下划线&lt;/strong>.大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字.&lt;/p></description></item><item><title>golang基础类型</title><link>https://daemon365.dev/post/go/golang_basic_types/</link><pubDate>Sat, 22 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golang_basic_types/</guid><description>&lt;h2 id="整型">整型
&lt;a class="header-anchor" href="#%e6%95%b4%e5%9e%8b">&lt;/a>
&lt;/h2>&lt;p>Go语言同时提供了有符号和无符号类型的整数运算。这里有&lt;strong>int8&lt;/strong>、&lt;strong>int16&lt;/strong>、&lt;strong>int32&lt;/strong>和&lt;strong>int64&lt;/strong>四种截然不同大小的有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，与此对应的是&lt;strong>uint8&lt;/strong>、&lt;strong>uint16&lt;/strong>、&lt;strong>uint32&lt;/strong>和&lt;strong>uint64&lt;/strong>四种无符号整数类型。&lt;/p></description></item><item><title>golang接口</title><link>https://daemon365.dev/post/go/golang_interface/</link><pubDate>Sat, 22 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golang_interface/</guid><description>&lt;h2 id="接口的定义">接口的定义
&lt;a class="header-anchor" href="#%e6%8e%a5%e5%8f%a3%e7%9a%84%e5%ae%9a%e4%b9%89">&lt;/a>
&lt;/h2>&lt;p>接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。&lt;/p></description></item><item><title>golang time包</title><link>https://daemon365.dev/post/go/golang_time_package/</link><pubDate>Fri, 21 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golang_time_package/</guid><description>&lt;h2 id="时间类型">时间类型
&lt;a class="header-anchor" href="#%e6%97%b6%e9%97%b4%e7%b1%bb%e5%9e%8b">&lt;/a>
&lt;/h2>&lt;p>time.Time类型表示时间。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">demo&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">now&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Now&lt;/span>() &lt;span style="color:#75715e">//获取当前时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Now:%v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">now&lt;/span>) &lt;span style="color:#75715e">// Now:2020-08-19 21:53:31.1633023 +0800 CST m=+0.003989401
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">year&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">now&lt;/span>.&lt;span style="color:#a6e22e">Year&lt;/span>() &lt;span style="color:#75715e">//年
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">month&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">now&lt;/span>.&lt;span style="color:#a6e22e">Month&lt;/span>() &lt;span style="color:#75715e">//月
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">day&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">now&lt;/span>.&lt;span style="color:#a6e22e">Day&lt;/span>() &lt;span style="color:#75715e">//日
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">hour&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">now&lt;/span>.&lt;span style="color:#a6e22e">Hour&lt;/span>() &lt;span style="color:#75715e">//小时
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">minute&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">now&lt;/span>.&lt;span style="color:#a6e22e">Minute&lt;/span>() &lt;span style="color:#75715e">//分钟
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">second&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">now&lt;/span>.&lt;span style="color:#a6e22e">Second&lt;/span>() &lt;span style="color:#75715e">//秒
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%d-%02d-%02d %02d:%02d:%02d\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">year&lt;/span>, &lt;span style="color:#a6e22e">month&lt;/span>, &lt;span style="color:#a6e22e">day&lt;/span>, &lt;span style="color:#a6e22e">hour&lt;/span>, &lt;span style="color:#a6e22e">minute&lt;/span>, &lt;span style="color:#a6e22e">second&lt;/span>) &lt;span style="color:#75715e">// 2020-08-19 21:53:31
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="时间戳">时间戳
&lt;a class="header-anchor" href="#%e6%97%b6%e9%97%b4%e6%88%b3">&lt;/a>
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">stamp&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">now&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">time&lt;/span>.&lt;span style="color:#a6e22e">Now&lt;/span>() &lt;span style="color:#75715e">//获取当前时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">timestamp1&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">now&lt;/span>.&lt;span style="color:#a6e22e">Unix&lt;/span>() &lt;span style="color:#75715e">//时间戳
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">timestamp2&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">now&lt;/span>.&lt;span style="color:#a6e22e">UnixNano&lt;/span>() &lt;span style="color:#75715e">//纳秒时间戳
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;秒时间戳:%v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">timestamp1&lt;/span>) &lt;span style="color:#75715e">// 秒时间戳:1597845356
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>	&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;纳秒时间戳:%v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">timestamp2&lt;/span>) &lt;span style="color:#75715e">// 纳秒时间戳:1597845356562315400
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用time.Unix()函数可以将时间戳转为时间格式。&lt;/p></description></item><item><title>golang error错误处理</title><link>https://daemon365.dev/post/go/golang_error_error_handling/</link><pubDate>Thu, 20 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golang_error_error_handling/</guid><description>&lt;h2 id="error定义">error定义
&lt;a class="header-anchor" href="#error%e5%ae%9a%e4%b9%89">&lt;/a>
&lt;/h2>&lt;h3 id="数据结构">数据结构
&lt;a class="header-anchor" href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84">&lt;/a>
&lt;/h3>&lt;p>go语言error是一普通的值，实现方式为简单一个接口。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// The error built-in interface type is the conventional interface for
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// representing an error condition, with the nil value representing no error.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#66d9ef">error&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Error&lt;/span>() &lt;span style="color:#66d9ef">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>创建error&lt;/p>
&lt;p>使用&lt;code>errors.New()&lt;/code>&lt;/p></description></item><item><title>golang fmt包</title><link>https://daemon365.dev/post/go/golang_fmt_package/</link><pubDate>Thu, 20 Jun 2019 00:00:00 +0800</pubDate><guid>https://daemon365.dev/post/go/golang_fmt_package/</guid><description>&lt;h2 id="fmt">fmt
&lt;a class="header-anchor" href="#fmt">&lt;/a>
&lt;/h2>&lt;p>fmt包实现了类似C语言printf和scanf的格式化I/O。主要分为向外输出内容和获取输入内容两大部分。&lt;/p>
&lt;h2 id="向外输出">向外输出
&lt;a class="header-anchor" href="#%e5%90%91%e5%a4%96%e8%be%93%e5%87%ba">&lt;/a>
&lt;/h2>&lt;p>标准库fmt提供了以下几种输出相关函数。&lt;/p></description></item></channel></rss>