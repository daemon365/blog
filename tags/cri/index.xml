<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Cri on Daemon365</title><link>https://daemon365.dev/tags/cri/</link><description>Don't let yourself stop.</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 09 May 2024 20:56:00 +0800</lastBuildDate><atom:link href="https://daemon365.dev/tags/cri/index.xml" rel="self" type="application/rss+xml"/><item><title>docker containerd runc containerd-shim等组件的关系</title><link>https://daemon365.dev/post/cloud/the_relationship_between_docker_containerd_runc_containerd_shim_and_other_components/</link><pubDate>Thu, 09 May 2024 20:56:00 +0800</pubDate><guid>https://daemon365.dev/post/cloud/the_relationship_between_docker_containerd_runc_containerd_shim_and_other_components/</guid><description>&lt;h2 id="早期-kubelet-创建容器工作原理"&gt;早期 kubelet 创建容器工作原理&lt;/h2&gt;
&lt;p&gt;因为 docker 出生的比 k8s 早，所以 k8s 早期的容器运行时都是基于 docker 的，kubelet 通过 docker 的 api 创建容器。后来，k8s 官方不想绑死在 docker 这架马车上，就把容器运行时抽象出来，定义了一个接口，叫 CRI (&lt;a href="https://github.com/kubernetes/cri-api"&gt;container runtime interface&lt;/a&gt;)，容器运行时接口, 通过这个接口，kubelet 可以和任何容器运行时交互。但是，docker 并没有实现这个接口，k8s 也不想直接失去 docker 的用户，所以 k8s 官方在 kubelet 中实现了一个叫 docker-shim 的组件，这个组件简单来说就是把 cri 接口转换成 docker 的 api，这样 kubelet 就可以和 docker 交互了, 这个组件在 kuberbetes 1.24 版本中已经被移除了。至于实现了 cri 接口的容器运行时，比如 containerd，cri-o 等，kubelet 可以直接和它们交互。&lt;/p&gt;
&lt;p&gt;调用架构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src="https://daemon365.dev/images/481a4d67-401a-4e8e-af61-3534d23a7d69.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;目前 dockershim 组件已经删除，不能使用了，所以 k8s 1.24 版本之后，kubelet 只能和实现了 cri 接口的容器运行时交互，比如 containerd，cri-o 等。&lt;/p&gt;
&lt;p&gt;这里建议使用 containerd 因为 containerd 是 docker 官方出品的，而且 containerd 也是 docker 的核心组件，docker 的容器运行时就是基于 containerd 的，所以 containerd 的稳定性和可靠性都是有保障的。&lt;/p&gt;</description><content:encoded><![CDATA[<h2 id="早期-kubelet-创建容器工作原理">早期 kubelet 创建容器工作原理</h2>
<p>因为 docker 出生的比 k8s 早，所以 k8s 早期的容器运行时都是基于 docker 的，kubelet 通过 docker 的 api 创建容器。后来，k8s 官方不想绑死在 docker 这架马车上，就把容器运行时抽象出来，定义了一个接口，叫 CRI (<a href="https://github.com/kubernetes/cri-api">container runtime interface</a>)，容器运行时接口, 通过这个接口，kubelet 可以和任何容器运行时交互。但是，docker 并没有实现这个接口，k8s 也不想直接失去 docker 的用户，所以 k8s 官方在 kubelet 中实现了一个叫 docker-shim 的组件，这个组件简单来说就是把 cri 接口转换成 docker 的 api，这样 kubelet 就可以和 docker 交互了, 这个组件在 kuberbetes 1.24 版本中已经被移除了。至于实现了 cri 接口的容器运行时，比如 containerd，cri-o 等，kubelet 可以直接和它们交互。</p>
<p>调用架构图如下：</p>
<p><img src="/images/481a4d67-401a-4e8e-af61-3534d23a7d69.png" alt=""></p>
<p>目前 dockershim 组件已经删除，不能使用了，所以 k8s 1.24 版本之后，kubelet 只能和实现了 cri 接口的容器运行时交互，比如 containerd，cri-o 等。</p>
<p>这里建议使用 containerd 因为 containerd 是 docker 官方出品的，而且 containerd 也是 docker 的核心组件，docker 的容器运行时就是基于 containerd 的，所以 containerd 的稳定性和可靠性都是有保障的。</p>
<h2 id="docker-containerd-runc-的关系">docker containerd runc 的关系</h2>
<p>因为 podman 等新兴 container runtime 的崛起，docker 不想失去定义标准的机会，所以 docker 官方把 containerd 从 docker 中分离出来，独立成一个项目，实现了 cri 接口，这种 kubelet 就可以通过 cri 直接调用 containerd 了。然后，docker 官方又把 runc 从 containerd 中分离出来，独立成一个项目，定义了一个叫 OCI (<a href="https://opencontainers.org/">Open Container Initiative</a>) 的标准，这个标准定义了容器的格式和运行时，runc 就是这个标准的实现，目前实现  oci 的还有 crun youki keta 等。</p>
<p>因为 containerd 和 runc 脱胎于 docker，docker 又不能维护两份代码，所以 docker 就通过调用 containerd ，containerd 再 通过配置实现 oci 标准的 runc 来创建容器。 当然，你也可以手动配置其他实现了 oci 标准的容器运行时。</p>
<p>调用架构图如下：</p>
<p><img src="/images/d7b1939a-5608-43da-a883-42ad662e94c7.png" alt=""></p>
<p>在上图中可以看到 containerd 不是直接调用 runc 的，而是通过 containerd-shim 来调用 runc 的，这个是为什么？</p>
<h2 id="runc">runc</h2>
<p>runc 是一款设计精巧的命令行工具，专注于创建和运行符合 Open Container Initiative（OCI）规范的容器。执行 runc start 时，它首先通过 fork 创建一个子进程，在这个新进程中进行一系列容器运行的准备工作，包括准备文件系统、配置 namespaces 和 cgroups 。接着，通过 execve 系统调用，这个子进程变身为容器的首个进程——通常被称作“init”进程——并执行用户指定的首个命令（例如，bash）。</p>
<p>如果首个命令是一个shell（比如 bash），当执行一个shell命令（例如 ls）时，bash 会 fork 并执行相应的子进程。这个新的子进程执行 ls 命令并在完成任务后退出。此后，bash 可能继续接受新的命令，或在结束会话后终止。</p>
<p>当容器的“init”进程终止时，整个容器也会按照规定的生命周期走向结束。不同的命令和应用会在这个基本框架下有不同的具体行为，但总体流程大致一致。</p>
<p>如果这些容器的进的父进程是 containerd ，那么当 containerd 进程挂掉或者重启时，容器的进程也会挂掉，这样就不符合容器的定义了，所以 containerd 通过 containerd-shim 来调用 runc，这样当 containerd 挂掉时，容器的进程还是会继续运行的。</p>
<h2 id="containerd-shim">containerd-shim</h2>
<p>containerd-shim 是一个轻量级的代理进程，它的主要作用是：</p>
<ol>
<li>通过runC命令可以启动、执行容器、进程；</li>
<li>监控容器进程状态，当容器执行完成后，通过exit fifo文件报告容器进程结束状态；</li>
<li>当此容器SHIM的第一个实例进程被杀死后，reaper掉所有其子进程；</li>
</ol>
<p>当 containerd 通过 containerd-shim 来调用 runc 后, 会把 containerd-shim 的挂到 system （pid=1）的进程下，这样当 containerd 挂掉或者重启时，containerd-shim 还是会继续运行的，这样就保证了容器的进程不会挂掉。</p>
<p>验证，这里我随便启动了一下 docker 容器看下效果：</p>
<div class="highlight"><pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-BASH" data-lang="BASH"><span style="display:flex;"><span><span style="color:#75715e"># 启动的nginx 容器</span>
</span></span><span style="display:flex;"><span>root       <span style="color:#ae81ff">19455</span>   <span style="color:#ae81ff">19435</span>  <span style="color:#ae81ff">0</span> 22:20 ?        00:00:00 nginx: master process nginx -g daemon off<span style="color:#111">;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># nginx 进程的父进程是 containerd-shim</span>
</span></span><span style="display:flex;"><span>root       <span style="color:#ae81ff">19435</span>       <span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">0</span> 22:20 ?        00:00:00 /usr/bin/containerd-shim-runc-v2 -namespace moby -id 0af95b326dfc8fee31bd28abb61e5d23a9cee98fada2b32c5ade852a0782f559 -address /run/containerd/containerd.sock
</span></span><span style="display:flex;"><span><span style="color:#75715e"># containerd-shim 的父进程是 systemd</span>
</span></span></code></pre></div>]]></content:encoded><category>cloud</category><category>docker</category><category>containerd</category><category>runc</category><category>containerd-shim</category><category>kubernetes</category><category>cri</category></item></channel></rss>