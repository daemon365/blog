<!doctype html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.136.5"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/favicon.ico><meta itemprop=name content="grpc服务发现与负载均衡"><meta itemprop=description content="Don't let yourself stop."><meta name=description content="Don't let yourself stop."><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://daemon365.dev/imgs/daemon365.png"><meta itemprop=keywords content="grpc,go"><meta property="og:type" content="article"><meta property="og:title" content="grpc服务发现与负载均衡"><meta property="og:description" content="Don't let yourself stop."><meta property="og:image" content="/imgs/daemon365.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://daemon365.dev/post/microservice/grpc_service_discovery_and_load_balancing/"><meta property="og:site_name" content="Daemon"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="daemon365"><meta property="article:published_time" content="2020-12-20 00:00:00 +0800 +0800"><meta property="article:modified_time" content="2020-12-20 00:00:00 +0800 +0800"><link type=text/css rel=stylesheet href=https://daemon365.dev/3rd/font-awesome/6.6.0/css/all.min.css><link type=text/css rel=stylesheet href=https://daemon365.dev/3rd/animate.css/4.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://daemon365.dev/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href=/css/main.min.db412bd9ac28b4d2ef3191f82f07ea936e2d087816acf6d6ed4bc87362c7e9f0.css><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":true,"isHome":false,"isPage":true,"path":"grpc_service_discovery_and_load_balancing","permalink":"https://daemon365.dev/post/microservice/grpc_service_discovery_and_load_balancing/","title":"grpc服务发现与负载均衡","waline":{"js":[{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"2.15.8"},{"alias":"@waline/client","alias_name":"waline","file":"dist/comment.js","name":"comment","version":"2.15.8"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.id="LA_COLLECT",e.src="https://sdk.51.la/js-sdk-pro.min.js",e.async="true",e.onload=function(){LA.init({id:"JmAHxEAUVgyS8B1c",ck:"JmAHxEAUVgyS8B1c",autoTrack:!0})},document.head.appendChild(e)})</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>grpc服务发现与负载均衡 - Daemon</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Daemon</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>Don't let yourself stop.</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>Home</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>About</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>Archives
<span class=badge>93</span></a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>Commonweal</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#负载均衡--服务发现>负载均衡 && 服务发现</a><ul><li><ul><li><a href=#基础>基础</a></li><li><a href=#服务发现概念>服务发现概念</a></li><li><a href=#负载均衡概念>负载均衡概念</a></li><li><a href=#集中式-lbproxy-model>集中式 LB（Proxy Model）</a></li><li><a href=#进程内-lbbalancing-aware-client>进程内 LB（Balancing-aware Client）</a></li><li><a href=#独立-lb-进程external-load-balancing-service>独立 LB 进程（External Load Balancing Service）</a></li></ul></li><li><a href=#grpc-内置的方案>gRPC 内置的方案</a></li></ul></li><li><a href=#grpc-负载均衡的运行机制>gRPC 负载均衡的运行机制</a></li><li><a href=#负载均衡的算法及实现>负载均衡的算法及实现</a></li><li><a href=#grpc-服务治理的优势>gRPC 服务治理的优势</a></li><li><a href=#resolver-暴露的三个接口>Resolver 暴露的三个接口</a></li><li><a href=#梳理-resolver-过程>梳理 Resolver 过程</a></li><li><a href=#文章转自>文章转自：</a></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=daemon365 src=/imgs/img-lazy-loading.gif data-src=/imgs/daemon365.png><p class=site-author-name itemprop=name>daemon365</p><div class=site-description itemprop=description>Don't let yourself stop.</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>93</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>7</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>52</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/daemon365 title="Github → https://github.com/daemon365" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://go-kratos.dev title=https://go-kratos.dev target=_blank>kratos</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script><script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://daemon365.dev/post/microservice/grpc_service_discovery_and_load_balancing/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/daemon365.png"><meta itemprop=name content="daemon365"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="daemon365"><meta itemprop=description content="Don't let yourself stop."></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="grpc服务发现与负载均衡"><meta itemprop=description content="前言

   在后台服务开发中，高可用性是构建中核心且重要的一环。服务发现（Service discovery）和负载均衡（Load Balance）一直都是我关注的话题。今天来谈一下我在实际中是如何理解及落地的。"></span><header class=post-header><h1 class=post-title itemprop="name headline">grpc服务发现与负载均衡</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2020-12-20 00:00:00 +0800 +0800" itemprop="dateCreated datePublished" datetime="2020-12-20 00:00:00 +0800 +0800">2020-12-20
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/microservice itemprop=url rel=index><span itemprop=name>microservice</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="fas fa-solid fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>4493</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="fas fa-solid fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>9分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=busuanzi_value_page_pv data-path=/post/microservice/grpc_service_discovery_and_load_balancing/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><h2 id=前言>前言
<a class=header-anchor href=#%e5%89%8d%e8%a8%80></a></h2><p>   在后台服务开发中，高可用性是构建中核心且重要的一环。服务发现（Service discovery）和负载均衡（Load Balance）一直都是我关注的话题。今天来谈一下我在实际中是如何理解及落地的。</p><h2 id=负载均衡--服务发现>负载均衡 && 服务发现
<a class=header-anchor href=#%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1--%e6%9c%8d%e5%8a%a1%e5%8f%91%e7%8e%b0></a></h2><h4 id=基础>基础
<a class=header-anchor href=#%e5%9f%ba%e7%a1%80></a></h4><p>   负载均衡 ，顾名思义，是通过某种手段将流量 / 请求分配到不通的服务器上去，保证后台的每个服务收到的请求都尽可能保持平衡
   服务发现 ，就是指客户端按照某种约定的方式主动去（注册中心）寻找服务，然后再连接相应的服务
   关于负载均衡的构建与实现，可以看下这几篇文章：</p><ul><li><a href=https://segmentfault.com/a/1190000008672912 title="gRPC 服务发现 & 负载均衡" rel="noopener external nofollow noreferrer" target=_blank class=exturl>gRPC 服务发现 & 负载均衡
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://grpc.io/blog/loadbalancing/ title="gRPC Load Balancing" rel="noopener external nofollow noreferrer" target=_blank class=exturl>gRPC Load Balancing
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://github.com/grpc/grpc/blob/master/doc/load-balancing.md title="Load Balancing in gRPC" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Load Balancing in gRPC
<i class="fa fa-external-link-alt"></i></a></li></ul><h4 id=服务发现概念>服务发现概念
<a class=header-anchor href=#%e6%9c%8d%e5%8a%a1%e5%8f%91%e7%8e%b0%e6%a6%82%e5%bf%b5></a></h4><p>   我们说的服务发现，一般理解为客户端如何发现 (并连接到) 服务，这里一般包含三个组件：</p><ol><li>服务消费者：一般指客户端（可以是简单的 TCP-Client 或者是 RPC-Client ）</li><li>服务提供者：一般指服务提供方，如传统服务，微服务等</li><li>服务注册中心：用来存储（Key-Value）服务提供者的服务，一般以 DNS/HTTP/RPC 等方式对外暴露接口</li></ol><h4 id=负载均衡概念>负载均衡概念
<a class=header-anchor href=#%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1%e6%a6%82%e5%bf%b5></a></h4><p>我们把 LB 看作一个组件，根据组件位置的不同，大致上分为三种：</p><h4 id=集中式-lbproxy-model>集中式 LB（Proxy Model）
<a class=header-anchor href=#%e9%9b%86%e4%b8%ad%e5%bc%8f-lbproxy-model></a></h4><p>   独立的 LB, 可以是硬件实现，如 F5，或者是 nginx 这种内置 Proxy-pass 或者 upstream 功能的网关，亦或是 LVS/HAPROXY，之前也使用
<a href=http://core.dpdk.org/doc/quick-start/ title=DPDK rel="noopener external nofollow noreferrer" target=_blank class=exturl>DPDK
<i class="fa fa-external-link-alt"></i>
</a>开发过类似的专用网关。</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/600380fe-75ab-44af-9615-c41dd981f499.png alt></p><h4 id=进程内-lbbalancing-aware-client>进程内 LB（Balancing-aware Client）
<a class=header-anchor href=#%e8%bf%9b%e7%a8%8b%e5%86%85-lbbalancing-aware-client></a></h4><p>   进程内 LB（集成到客户端），此方案将 LB 的功能集成到服务消费方进程里，也被称为软负载或者客户端负载方案。服务提供方启动时，首先将服务地址注册到服务注册表，同时定期报心跳到服务注册表以表明服务的存活状态，相当于健康检查，服务消费方要访问某个服务时，它通过内置的 LB 组件向服务注册表查询，同时缓存并定期刷新目标服务地址列表，然后以某种负载均衡策略选择一个目标服务地址，最后向目标服务发起请求。LB 和服务发现能力被分散到每一个服务消费者的进程内部，同时服务消费方和服务提供方之间是直接调用，没有额外开销，性能比较好。</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/484f3293-3b5e-4606-ade5-7b69ac18f7fb.png alt></p><h4 id=独立-lb-进程external-load-balancing-service>独立 LB 进程（External Load Balancing Service）
<a class=header-anchor href=#%e7%8b%ac%e7%ab%8b-lb-%e8%bf%9b%e7%a8%8bexternal-load-balancing-service></a></h4><p>   该方案是针对上一种方案的不足而提出的一种折中方案，原理和第二种方案基本类似。不同之处是将 LB 和服务发现功能从进程内移出来，变成主机上的一个独立进程。主机上的一个或者多个服务要访问目标服务时，他们都通过同一主机上的独立 LB 进程做服务发现和负载均衡。该方案也是一种分布式方案没有单点问题，一个 LB 进程挂了只影响该主机上的服务调用方，服务调用方和 LB 之间是进程内调用性能好，同时该方案还简化了服务调用方，不需要为不同语言开发客户库，LB 的升级不需要服务调用方改代码。 公司的 L5 是这种方式，每台机器上都安装了 L5 的 agent，供其他服务调用。该方案主要问题：部署较复杂，环节多，出错调试排查问题不方便。</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/be553bb2-7a9a-4539-93db-02cd4a2d1ee2.png alt></p><h3 id=grpc-内置的方案>gRPC 内置的方案
<a class=header-anchor href=#grpc-%e5%86%85%e7%bd%ae%e7%9a%84%e6%96%b9%e6%a1%88></a></h3><p>  gRPC 的内置方案如下图所示：</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/4bc0b344-b882-415c-9972-75ad14e35d51.png alt></p><p>gRPC 在官网文档中提供了实现 LB 的思路，并在不同语言的 gRPC 代码 API 中已提供了命名解析和负载均衡接口供扩展。默认提供了 DNS-resolver 的实现，接口相当规范，实现起来也不复杂，只需要实现服务注册（Registry）和服务监听 + 解析（Watcher+Resolver）的逻辑就行了，这里简单介绍其基本实现过程：</p><ol><li>构建注册中心，这里注册中心一般要求具备分布式一致性（满足 CAP 定理的 AP 或 CP）的高可用的组件集群，如 Zookeeper、Consul、Etcd 等</li><li>构建 gRPC 服务端的注册逻辑，服务启动后定时向注册中心注册自身的关键信息（一般开启新的 groutine 来完成），至少包含 IP 和端口，其他可选信息，如自身的负载信息（CPU 和 Memory）、当前实时连接数等，这些辅助信息有助于帮助系统更好的执行 LB 算法</li><li>gRPC 客户端向注册中心发出服务解析请求，注册中心将请求中关联的所有服务的信息返回给 gRPC 客户端，客户端与所有在线的服务建立起 HTTP2 长连接</li><li>gRPC 客户端发起 RPC 调用，根据 LB 均衡器中实现的负载均衡策略（gRPC 中默认提供的算法是 RoundRobin），选择其中一 HTTP2 长连接进行通信，即 LB 策略决定哪个子通道 - 即哪个 gRPC 服务器将接收请求</li></ol><h2 id=grpc-负载均衡的运行机制>gRPC 负载均衡的运行机制
<a class=header-anchor href=#grpc-%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1%e7%9a%84%e8%bf%90%e8%a1%8c%e6%9c%ba%e5%88%b6></a></h2><p>gRPC 提供了负载均衡实现的用户侧接口，我们可以非常方便的定制化业务的负载均衡策略，为了理解 gRPC 的负载均衡的实现机制，后续博客中我会分析下 <code>gRPC</code> 实现负载均衡的代码。</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/c0b8b2f7-eee6-4a7b-8785-331d276a19fd.png alt></p><ol><li>Resolver<ul><li>解析器，用于从注册中心实时获取当前服务端的列表，同步发送给 Balancer</li></ul></li><li>Balancer<ul><li>平衡器，一是接收从 Resolver 发送的服务端列表，建立并维护（长）连接状态；二是每次当 Client 发起 Rpc 调用时，按照一定算法从连接池中选择一个连接进行 Rpc 调用</li></ul></li><li>Register<ul><li>注册，用于服务端初始化和在线时，将自己信息上报到注册中心，主要信息有 Ip，端口等</li></ul></li></ol><h2 id=负载均衡的算法及实现>负载均衡的算法及实现
<a class=header-anchor href=#%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1%e7%9a%84%e7%ae%97%e6%b3%95%e5%8f%8a%e5%ae%9e%e7%8e%b0></a></h2><p>在实践中，如何选取负载均衡策略是一个很有趣的话题，例如 Nginx 的 <code>upstream</code> 机制中就有很多经典的 LB 策略，如带权重的轮询
<a href=https://github.com/nginx/nginx/blob/master/src/http/ngx_http_upstream_round_robin.c title=Weight-RoundRobin rel="noopener external nofollow noreferrer" target=_blank class=exturl>Weight-RoundRobin
<i class="fa fa-external-link-alt"></i>
</a>，一般常用的负载均衡方法有如下几种：</p><ol><li>RoundRobin（轮询）</li><li>Weight-RoundRobin（加权轮询）<ul><li>不同的后端服务器可能机器的配置和当前系统的负载并不相同，因此它们的抗压能力也不相同。给配置高、负载低的机器配置更高的权重，而配置低、负载高的机器，给其分配较低的权重，降低其系统负载，加权轮询能很好地处理这一问题，并将请求顺序且按照权重分配到后端。</li></ul></li><li>Random（随机）</li><li>Weight-Random（加权随机）<ul><li>通过系统的随机算法，根据后端服务器的列表随机选取其中的一台服务器进行访问</li></ul></li><li>源地址哈希法<ul><li>源地址哈希的思想是根据获取客户端的 IP 地址，通过哈希函数计算得到的一个数值，用该数值对服务器列表的大小进行取模运算，得到的结果便是客服端要访问服务器的序号。采用源地址哈希法进行负载均衡，同一 IP 地址的客户端，当后端服务器列表不变时，它每次都会映射到同一台后端服务器进行访问</li></ul></li><li>最小连接数法<ul><li>最小连接数算法比较灵活和智能，由于后端服务器的配置不尽相同，对于请求的处理有快有慢，它是根据后端服务器当前的连接情况，动态地选取其中当前积压连接数最少的一台服务器来处理当前的请求，尽可能地提高后端服务的利用效率，将负责合理地分流到每一台服务器</li></ul></li><li>一致性哈希算法<ul><li>常见的是 <code>Ketama</code> 算法，该算法是用来解决 <code>cache</code> 失效导致的缓存穿透的问题的，当然也可以适用于 gRPC 长连接的场景</li></ul></li></ol><h2 id=grpc-服务治理的优势>gRPC 服务治理的优势
<a class=header-anchor href=#grpc-%e6%9c%8d%e5%8a%a1%e6%b2%bb%e7%90%86%e7%9a%84%e4%bc%98%e5%8a%bf></a></h2><p>   在现网环境中，后端服务就是采用了 gRPC 与 Etcd 的服务治理方案，总结下有这么几个优点；</p><ul><li>采用了 gRPC 实现负载均衡策略，模块之间通信采用长连接方式，避免每次 RPC 调用时新建连接的开销，充分发挥 <code>HTTP2</code> 的优势</li><li>扩容和缩容都及其方便，例如扩容，只要部署上服务，运行后，服务成功注册到 Etcd 便大功告成</li><li>灵活的自定义的 LB 算法，使得后端压力更为均衡</li><li>客户端加入重试逻辑，使得网络抖动情况下，可以通过重试连接上另外一台服务</li></ul><h2 id=resolver-暴露的三个接口>Resolver 暴露的三个接口
<a class=header-anchor href=#resolver-%e6%9a%b4%e9%9c%b2%e7%9a%84%e4%b8%89%e4%b8%aa%e6%8e%a5%e5%8f%a3></a></h2><p>前文说过，gRPC 内置的服务治理功能，对开发者暴露了服务发现的 <code>interface{}</code>，<code>resolver.Builder</code> 和 <code>resolver.ClientConn</code> 和 <code>resolver.Resolver</code>，
<a href=https://github.com/grpc/grpc-go/blob/master/resolver/resolver.go title=相关代码 rel="noopener external nofollow noreferrer" target=_blank class=exturl>相关代码
<i class="fa fa-external-link-alt"></i>
</a>。开发者在实例化这三个接口之后，就可以实现从指定的 scheme 中获取服务列表，通知 balancer 并与这些服务端建立 RPC 长连接。</p><ol><li>resolver.Builder</li><li>resolver.ClientConn</li><li>resolver.Resolver</li></ol><ul><li>resolver.Builder <code>Builder</code> 用于 gRPC 内部创建 <code>Resolver</code> 接口的实现，但注意内部声明的 <code>Build()</code> 方法将接口 <code>ClientConn</code> 作为参数传入了，在前文的分析中，我们了解到 <code>ClientConn</code>
<a href=https://github.com/grpc/grpc-go/blob/master/clientconn.go#L459 title=结库 rel="noopener external nofollow noreferrer" target=_blank class=exturl>结库
<i class="fa fa-external-link-alt"></i>
</a>是非常重要的结构，其成员 <code>conns map[*addrConn]struct{}</code> 中维护了所有从注册中心获取到的服务端列表。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Builder creates a resolver that will be used to watch name resolution updates.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Builder</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>// Build creates a new resolver for the given target.
</span></span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>// gRPC dial calls Build synchronously, and fails if the returned error is
</span></span></span><span style=display:flex><span><span style=color:#75715e>// not nil.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>Build</span>(<span style=color:#a6e22e>target</span> <span style=color:#a6e22e>Target</span>, <span style=color:#a6e22e>cc</span> <span style=color:#a6e22e>ClientConn</span>, <span style=color:#a6e22e>opts</span> <span style=color:#a6e22e>BuildOption</span>) (<span style=color:#a6e22e>Resolver</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// Scheme returns the scheme supported by this resolver.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Scheme is defined at https://github.com/grpc/grpc/blob/master/doc/naming.md.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>Scheme</span>() <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><a href=https://github.com/grpc/grpc-go/blob/master/clientconn.go#L459 title=resolver.ClientConn rel="noopener external nofollow noreferrer" target=_blank class=exturl>resolver.ClientConn
<i class="fa fa-external-link-alt"></i>
</a><code>ClientConn</code> 接口中，<code>UpdateState</code> 方法需要传入 <code>State</code> 结构，<code>NewAddress</code> 方法需要传入 <code>Address</code> 结构，看代码可以发现其中包含了 <code>Addresses []Address // Resolved addresses for the target</code>，可以看出是需要将服务发现得到的 <code>Address</code> 对象列表告诉 <code>ClientConn</code> 的对象。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// ClientConn contains the callbacks for resolver to notify any updates
</span></span></span><span style=display:flex><span><span style=color:#75715e>// to the gRPC ClientConn.
</span></span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>// This interface is to be implemented by gRPC. Users should not need a
</span></span></span><span style=display:flex><span><span style=color:#75715e>// brand new implementation of this interface. For the situations like
</span></span></span><span style=display:flex><span><span style=color:#75715e>// testing, the new implementation should embed this interface. This allows
</span></span></span><span style=display:flex><span><span style=color:#75715e>// gRPC to add new methods to this interface.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>ClientConn</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>// UpdateState updates the state of the ClientConn appropriately.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>UpdateState</span>(<span style=color:#a6e22e>State</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// NewAddress is called by resolver to notify ClientConn a new list
</span></span></span><span style=display:flex><span><span style=color:#75715e>// of resolved addresses.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// The address list should be the complete list of resolved addresses.
</span></span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Deprecated: Use UpdateState instead.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>NewAddress</span>(<span style=color:#a6e22e>addresses</span> []<span style=color:#a6e22e>Address</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// NewServiceConfig is called by resolver to notify ClientConn a new
</span></span></span><span style=display:flex><span><span style=color:#75715e>// service config. The service config should be provided as a json string.
</span></span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Deprecated: Use UpdateState instead.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>NewServiceConfig</span>(<span style=color:#a6e22e>serviceConfig</span> <span style=color:#66d9ef>string</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>resolver.Resolver <code>Resolver</code> 提供了 <code>ResolveNow</code> 用于被 gRPC 尝试重新进行服务发现</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Resolver watches for the updates on the specified target.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Updates include address updates and service config updates.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Resolver</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>// ResolveNow will be called by gRPC to try to resolve the target name
</span></span></span><span style=display:flex><span><span style=color:#75715e>// again. It&#39;s just a hint, resolver can ignore this if it&#39;s not necessary.
</span></span></span><span style=display:flex><span><span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e>// It could be called multiple times concurrently.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ResolveNow</span>(<span style=color:#a6e22e>ResolveNowOption</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>// Close closes the resolver.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=梳理-resolver-过程>梳理 Resolver 过程
<a class=header-anchor href=#%e6%a2%b3%e7%90%86-resolver-%e8%bf%87%e7%a8%8b></a></h2><p>通过这三个接口，再次梳理下 gRPC 的服务发现实现逻辑</p><ol><li>通过 <code>Builder.Build()</code> 进行 <code>Reslover</code> 的创建，在 <code>Build()</code> 的过程中将服务发现的地址信息丢给 <code>ClientConn</code> 用于内部连接创建（通过 <code>ClientConn.UpdateState()</code> 实现）等逻辑；</li><li>当 <code>client</code> 在 <code>Dial</code> 时会根据 <code>target</code> 解析的 <code>scheme</code> 获取对应的 <code>Builder</code>，
<a href=https://github.com/grpc/grpc-go/blob/master/clientconn.go#L242 title=代码位置 rel="noopener external nofollow noreferrer" target=_blank class=exturl>代码位置
<i class="fa fa-external-link-alt"></i></a></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>DialContext</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>target</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>opts</span> <span style=color:#f92672>...</span><span style=color:#a6e22e>DialOption</span>) (<span style=color:#a6e22e>conn</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ClientConn</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Determine the resolver to use.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>parsedTarget</span> = <span style=color:#a6e22e>parseTarget</span>(<span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>target</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>grpclog</span>.<span style=color:#a6e22e>Infof</span>(<span style=color:#e6db74>&#34;parsed scheme: %q&#34;</span>, <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>parsedTarget</span>.<span style=color:#a6e22e>Scheme</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>resolverBuilder</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>getResolver</span>(<span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>parsedTarget</span>.<span style=color:#a6e22e>Scheme</span>)		<span style=color:#75715e>// 通过 scheme(名字) 获取对应的 resolver
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>resolverBuilder</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// If resolver builder is still nil, the parsed target&#39;s scheme is
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// not registered. Fallback to default resolver and set Endpoint to
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// the original target.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>grpclog</span>.<span style=color:#a6e22e>Infof</span>(<span style=color:#e6db74>&#34;scheme %q not registered, fallback to default scheme&#34;</span>, <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>parsedTarget</span>.<span style=color:#a6e22e>Scheme</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>parsedTarget</span> = <span style=color:#a6e22e>resolver</span>.<span style=color:#a6e22e>Target</span>{
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Scheme</span>:   <span style=color:#a6e22e>resolver</span>.<span style=color:#a6e22e>GetDefaultScheme</span>(),
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Endpoint</span>: <span style=color:#a6e22e>target</span>,
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>resolverBuilder</span> = <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>getResolver</span>(<span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>parsedTarget</span>.<span style=color:#a6e22e>Scheme</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>resolverBuilder</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;could not get resolver for default scheme: %q&#34;</span>, <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>parsedTarget</span>.<span style=color:#a6e22e>Scheme</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Build the resolver.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>rWrapper</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>newCCResolverWrapper</span>(<span style=color:#a6e22e>cc</span>, <span style=color:#a6e22e>resolverBuilder</span>)		<span style=color:#75715e>// 通过 gRPC 提供的 Wrapper，应用我们实现的 resolver 逻辑
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;failed to build resolver: %v&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>resolverWrapper</span> = <span style=color:#a6e22e>rWrapper</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>当 <code>Dial</code> 成功会创建出结构体 <code>ClientConn</code> 的对象
<a href=https://github.com/grpc/grpc-go/blob/master/clientconn.go#L447 title=官方代码位置 rel="noopener external nofollow noreferrer" target=_blank class=exturl>官方代码位置
<i class="fa fa-external-link-alt"></i>
</a>(注意不是上面的 <code>ClientConn</code> 接口)，可以看到结构体 <code>ClientConn</code> 内的成员 <code>resolverWrapper</code> 又实现了接口 <code>ClientConn</code> 的方法
<a href=https://github.com/grpc/grpc-go/blob/master/resolver_conn_wrapper.go title=官方代码位置 rel="noopener external nofollow noreferrer" target=_blank class=exturl>官方代码位置
<i class="fa fa-external-link-alt"></i></a></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>DialContext</span>(<span style=color:#a6e22e>ctx</span> <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Context</span>, <span style=color:#a6e22e>target</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>opts</span> <span style=color:#f92672>...</span><span style=color:#a6e22e>DialOption</span>) (<span style=color:#a6e22e>conn</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ClientConn</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span><span style=color:#75715e>// 初始化 CC
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>cc</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>ClientConn</span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>target</span>:            <span style=color:#a6e22e>target</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>csMgr</span>:             <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>connectivityStateManager</span>{},
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>conns</span>:             make(<span style=color:#66d9ef>map</span>[<span style=color:#f92672>*</span><span style=color:#a6e22e>addrConn</span>]<span style=color:#66d9ef>struct</span>{}),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dopts</span>:             <span style=color:#a6e22e>defaultDialOptions</span>(),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>blockingpicker</span>:    <span style=color:#a6e22e>newPickerWrapper</span>(),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>czData</span>:            new(<span style=color:#a6e22e>channelzData</span>),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>firstResolveEvent</span>: <span style=color:#a6e22e>grpcsync</span>.<span style=color:#a6e22e>NewEvent</span>(),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#a6e22e>cc</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li>当 <code>resolverWrapper</code> 被初始化时就会调用 <code>Build</code> 方法
<a href=https://github.com/grpc/grpc-go/blob/master/resolver_conn_wrapper.go#L89 title=官方代码位置 rel="noopener external nofollow noreferrer" target=_blank class=exturl>官方代码位置
<i class="fa fa-external-link-alt"></i>
</a>，其中参数为接口 <code>ClientConn</code> 传入的是 <code>ccResolverWrapper</code></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// newCCResolverWrapper uses the resolver.Builder to build a Resolver and
</span></span></span><span style=display:flex><span><span style=color:#75715e>// returns a ccResolverWrapper object which wraps the newly built resolver.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>newCCResolverWrapper</span>(<span style=color:#a6e22e>cc</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ClientConn</span>, <span style=color:#a6e22e>rb</span> <span style=color:#a6e22e>resolver</span>.<span style=color:#a6e22e>Builder</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>ccResolverWrapper</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span><span style=color:#a6e22e>ccr</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>ccResolverWrapper</span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cc</span>:   <span style=color:#a6e22e>cc</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>done</span>: <span style=color:#a6e22e>grpcsync</span>.<span style=color:#a6e22e>NewEvent</span>(),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>credsClone</span> <span style=color:#a6e22e>credentials</span>.<span style=color:#a6e22e>TransportCredentials</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>creds</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>dopts</span>.<span style=color:#a6e22e>copts</span>.<span style=color:#a6e22e>TransportCredentials</span>; <span style=color:#a6e22e>creds</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>credsClone</span> = <span style=color:#a6e22e>creds</span>.<span style=color:#a6e22e>Clone</span>()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>rbo</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>resolver</span>.<span style=color:#a6e22e>BuildOptions</span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DisableServiceConfig</span>: <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>dopts</span>.<span style=color:#a6e22e>disableServiceConfig</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>DialCreds</span>:            <span style=color:#a6e22e>credsClone</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CredsBundle</span>:          <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>dopts</span>.<span style=color:#a6e22e>copts</span>.<span style=color:#a6e22e>CredsBundle</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Dialer</span>:               <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>dopts</span>.<span style=color:#a6e22e>copts</span>.<span style=color:#a6e22e>Dialer</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// We need to hold the lock here while we assign to the ccr.resolver field
</span></span></span><span style=display:flex><span><span style=color:#75715e>// to guard against a data race caused by the following code path,
</span></span></span><span style=display:flex><span><span style=color:#75715e>// rb.Build--&gt;ccr.ReportError--&gt;ccr.poll--&gt;ccr.resolveNow, would end up
</span></span></span><span style=display:flex><span><span style=color:#75715e>// accessing ccr.resolver which is being assigned here.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>ccr</span>.<span style=color:#a6e22e>resolverMu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>ccr</span>.<span style=color:#a6e22e>resolverMu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>ccr</span>.<span style=color:#a6e22e>resolver</span>, <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>rb</span>.<span style=color:#a6e22e>Build</span>(<span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>parsedTarget</span>, <span style=color:#a6e22e>ccr</span>, <span style=color:#a6e22e>rbo</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ccr</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=5><li>当用户基于 <code>Builder</code> 的实现进行 <code>UpdateState</code> 调用时，则会触发结构体 <code>ClientConn</code> 的 <code>updateResolverState</code> 方法
<a href=https://github.com/grpc/grpc-go/blob/master/resolver_conn_wrapper.go#L109 title=官方代码位置 rel="noopener external nofollow noreferrer" target=_blank class=exturl>官方代码位置
<i class="fa fa-external-link-alt"></i>
</a>，<code>updateResolverState</code> 则会对传入的 <code>Address</code> 进行初始化等逻辑
<a href=https://github.com/grpc/grpc-go/blob/master/clientconn.go#L553 title=官方代码位置 rel="noopener external nofollow noreferrer" target=_blank class=exturl>官方代码位置
<i class="fa fa-external-link-alt"></i></a></li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>cc</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>ClientConn</span>) <span style=color:#a6e22e>updateResolverState</span>(<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>resolver</span>.<span style=color:#a6e22e>State</span>, <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>firstResolveEvent</span>.<span style=color:#a6e22e>Fire</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span><span style=color:#75715e>// Check if the ClientConn is already closed. Some fields (e.g.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// balancerWrapper) are set to nil when closing the ClientConn, and could
</span></span></span><span style=display:flex><span><span style=color:#75715e>// cause nil pointer panic if we don&#39;t have this check.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>conns</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// May need to apply the initial service config in case the resolver
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// doesn&#39;t support service configs, or doesn&#39;t provide a service config
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// with the new addresses.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>maybeApplyDefaultServiceConfig</span>(<span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>balancerWrapper</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>balancerWrapper</span>.<span style=color:#a6e22e>resolverError</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// No addresses are valid with err set; return early.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>balancer</span>.<span style=color:#a6e22e>ErrBadResolverState</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ret</span> <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>dopts</span>.<span style=color:#a6e22e>disableServiceConfig</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>ServiceConfig</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>maybeApplyDefaultServiceConfig</span>(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Addresses</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e>// TODO: do we need to apply a failing LB policy if there is no
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// default, per the error handling design?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sc</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>ServiceConfig</span>.<span style=color:#a6e22e>Config</span>.(<span style=color:#f92672>*</span><span style=color:#a6e22e>ServiceConfig</span>); <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>ServiceConfig</span>.<span style=color:#a6e22e>Err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>ok</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>applyServiceConfigAndBalancer</span>(<span style=color:#a6e22e>sc</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Addresses</span>)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>ret</span> = <span style=color:#a6e22e>balancer</span>.<span style=color:#a6e22e>ErrBadResolverState</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>balancerWrapper</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>err</span> <span style=color:#66d9ef>error</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>ServiceConfig</span>.<span style=color:#a6e22e>Err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>status</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#a6e22e>codes</span>.<span style=color:#a6e22e>Unavailable</span>, <span style=color:#e6db74>&#34;error parsing service config: %v&#34;</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>ServiceConfig</span>.<span style=color:#a6e22e>Err</span>)
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>status</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#a6e22e>codes</span>.<span style=color:#a6e22e>Unavailable</span>, <span style=color:#e6db74>&#34;illegal service config type: %T&#34;</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>ServiceConfig</span>.<span style=color:#a6e22e>Config</span>)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>blockingpicker</span>.<span style=color:#a6e22e>updatePicker</span>(<span style=color:#a6e22e>base</span>.<span style=color:#a6e22e>NewErrPicker</span>(<span style=color:#a6e22e>err</span>))
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>csMgr</span>.<span style=color:#a6e22e>updateState</span>(<span style=color:#a6e22e>connectivity</span>.<span style=color:#a6e22e>TransientFailure</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ret</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>balCfg</span> <span style=color:#a6e22e>serviceconfig</span>.<span style=color:#a6e22e>LoadBalancingConfig</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>dopts</span>.<span style=color:#a6e22e>balancerBuilder</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>sc</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>sc</span>.<span style=color:#a6e22e>lbConfig</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>balCfg</span> = <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>sc</span>.<span style=color:#a6e22e>lbConfig</span>.<span style=color:#a6e22e>cfg</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>cbn</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>curBalancerName</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>bw</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>balancerWrapper</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>cc</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>cbn</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>grpclbName</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Filter any grpclb addresses since we don&#39;t have the grpclb balancer.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt;len(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Addresses</span>); {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Addresses</span>[<span style=color:#a6e22e>i</span>].<span style=color:#a6e22e>Type</span> <span style=color:#f92672>==</span> <span style=color:#a6e22e>resolver</span>.<span style=color:#a6e22e>GRPCLB</span> {
</span></span><span style=display:flex><span>            copy(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Addresses</span>[<span style=color:#a6e22e>i</span>:], <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Addresses</span>[<span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>:])
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Addresses</span> = <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Addresses</span>[:len(<span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Addresses</span>)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>uccsErr</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bw</span>.<span style=color:#a6e22e>updateClientConnState</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>balancer</span>.<span style=color:#a6e22e>ClientConnState</span>{<span style=color:#a6e22e>ResolverState</span>: <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>BalancerConfig</span>: <span style=color:#a6e22e>balCfg</span>})
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ret</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ret</span> = <span style=color:#a6e22e>uccsErr</span> <span style=color:#75715e>// prefer ErrBadResolver state since any other error is
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// currently meaningless to the caller.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ret</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=6><li>至此整个服务发现过程就结束了。从中也可以看出 gRPC 官方提供的三个接口还是很灵活的，但也正因为灵活要实现稍微麻烦一些，而 <code>Address</code>
<a href=https://github.com/grpc/grpc-go/blob/master/resolver/resolver.go#L79 title=官方代码位置 rel="noopener external nofollow noreferrer" target=_blank class=exturl>官方代码位置
<i class="fa fa-external-link-alt"></i>
</a>如果直接被业务拿来用于服务节点信息的描述结构则显得有些过于简单。</li></ol><p>所以 <code>warden</code> 包装了 gRPC 的整个服务发现实现逻辑，代码分别位于 <code>pkg/naming/naming.go</code> 和 <code>warden/resolver/resolver.go</code>，其中：</p><ul><li><code>naming.go</code> 内定义了用于描述业务实例的 <code>Instance</code> 结构、用于服务注册的 <code>Registry</code> 接口、用于服务发现的 <code>Resolver</code> 接口</li><li><code>resolver.go</code> 内实现了 gRPC 官方的 <code>resolver.Builder</code> 和 <code>resolver.Resolver</code> 接口，但也暴露了 <code>naming.go</code> 内的 <code>naming.Builder</code> 和 <code>naming.Resolver</code> 接口</li></ul><h2 id=文章转自>文章转自：
<a class=header-anchor href=#%e6%96%87%e7%ab%a0%e8%bd%ac%e8%87%aa></a></h2><ul><li><a href=https://pandaychen.github.io/2019/07/11/GRPC-SERVICE-DISCOVERY/ title="基于 gRPC 的服务发现与负载均衡（基础篇） - 熊喵君的博客 | PANDAYCHEN" rel="noopener external nofollow noreferrer" target=_blank class=exturl>基于 gRPC 的服务发现与负载均衡（基础篇） - 熊喵君的博客 | PANDAYCHEN
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://pandaychen.github.io/2020/01/03/GRPC-RESOLVER-DEEP-ANALYSIS2-IN-KRATOS/ title="gRPC 应用篇之 Resolver 接口封装 - 熊喵君的博客 | PANDAYCHEN" rel="noopener external nofollow noreferrer" target=_blank class=exturl>gRPC 应用篇之 Resolver 接口封装 - 熊喵君的博客 | PANDAYCHEN
<i class="fa fa-external-link-alt"></i></a></li></ul></div><footer class=post-footer><div class=post-tags><a href=/tags/grpc>grpc
</a><a href=/tags/go>go</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right alt=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
grpc服务发现与负载均衡</li><li class=post-copyright-author><strong>本文作者： </strong>daemon365</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://daemon365.dev/post/microservice/grpc_service_discovery_and_load_balancing/ title=grpc服务发现与负载均衡>https://daemon365.dev/post/microservice/grpc_service_discovery_and_load_balancing/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/microservice/introduction_and_use_of_thrift/ rel=next title=thrift的介绍及其使用><i class="fa fa-chevron-left"></i> thrift的介绍及其使用</a></div><div class="post-nav-prev post-nav-item"><a href=/post/microservice/grpc_basics/ rel=prev title=grpc基础>grpc基础
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=utterances-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2019 - 2024
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>daemon365</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.136.5 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.6.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://daemon365.dev/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://daemon365.dev/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":false,"hostname":"https://daemon365.dev/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lawidget":{"id":"JmAHxEAUVgyS8B1c","js":"https://v6-widget.51.la/v6/laId/quote.js?theme=0\u0026col=true\u0026f=12\u0026display=0,0,0,1,0,1,1,1"},"lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":true,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"utterances":{"cfg":{"issueterm":"pathname","label":"comments","repo":"daemon365/blog","theme":"preferred-color-scheme"},"js":"https://utteranc.es/client.js"},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://daemon365.dev/3rd"}},"version":"4.6.3"}</script><script type=text/javascript src=/js/main.min.44e8f3a116669418a0551fcbff81fe26c85707505ea0b87a42f2d4116994b442.js defer></script></body></html>