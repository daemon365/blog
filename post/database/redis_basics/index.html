<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>redis基础 - Daemon365</title><link rel=icon href=/imgs/favicon.ico><link rel=manifest href=/manifest.json><meta name=theme-color content="#007aff"><meta name=mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="default"><meta name=apple-mobile-web-app-title content="Daemon365"><meta name=description content="redis介绍
Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。
Redis 与其他 key - value 缓存产品有以下三个特点：

Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
Redis不仅仅支持简单的 …"><meta name=keywords content="redis"><meta name=author content="daemon365"><meta property="og:type" content="article"><meta property="og:url" content="https://daemon365.dev/post/database/redis_basics/"><meta property="og:title" content="redis基础 - Daemon365"><meta property="og:description" content="redis介绍
Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。
Redis 与其他 key - value 缓存产品有以下三个特点：

Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
Redis不仅仅支持简单的 …"><meta property="og:image" content="https://daemon365.dev/imgs/avatar.svg"><meta property="og:locale" content="en"><meta property="og:site_name" content="Daemon365"><meta property="article:published_time" content="2020-03-20T00:00:00+08:00"><meta property="article:modified_time" content="2020-03-20T00:00:00+08:00"><meta property="article:author" content="daemon365"><meta property="article:section" content="database"><meta property="article:tag" content="redis"><meta name=twitter:card content="summary_large_image"><meta name=twitter:url content="https://daemon365.dev/post/database/redis_basics/"><meta name=twitter:title content="redis基础 - Daemon365"><meta name=twitter:description content="redis介绍
Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。
Redis 与其他 key - value 缓存产品有以下三个特点：

Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
Redis不仅仅支持简单的 …"><meta name=twitter:image content="https://daemon365.dev/imgs/avatar.svg"><link rel=canonical href=https://daemon365.dev/post/database/redis_basics/><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"redis基础","description":"\u003ch2 id=\u0022redis介绍\u0022\u003eredis介绍\u003c\/h2\u003e\n\u003cp\u003eRedis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。\u003c\/p\u003e\n\u003cp\u003eRedis 与其他 key - value 缓存产品有以下三个特点：\u003c\/p\u003e\n\u003cul\u003e\n\u003cli\u003eRedis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。\u003c\/li\u003e\n\u003cli\u003eRedis不仅仅支持简单的 …\u003c\/li\u003e\u003c\/ul\u003e","datePublished":"2020-03-20T00:00:00\u002b08:00","dateModified":"2020-03-20T00:00:00\u002b08:00","author":{"@type":"Person","name":"daemon365"},"publisher":{"@type":"Organization","name":"Daemon365","logo":{"@type":"ImageObject","url":"https:\/\/daemon365.dev\/imgs\/favicon.ico"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/daemon365.dev\/post\/database\/redis_basics\/"},"inLanguage":"en"}</script><meta name=robots content="index, follow"><meta name=googlebot content="index, follow"><link rel=stylesheet href=/css/components/variables.css><link rel=stylesheet href=/css/components/base.css><link rel=stylesheet href=/css/components/layout.css><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/css/components/search.css><link rel=stylesheet href=/css/components/toc.css><link rel=stylesheet href=/css/components/image-preview.css><link rel=stylesheet href=/css/components/reading-progress.css><style>:root{font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,helvetica neue,Arial,sans-serif}</style></head><body><div class=reading-progress-bar></div><header class=site-header><div class=container><div class=header-content><div class=site-branding><a href=/ class=site-logo><span class=site-title>Daemon365</span></a></div><nav class=site-nav><ul class=nav-menu><li><a href=/><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
Home</a></li><li><a href=/about><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>
About</a></li><li><a href=/archives><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/></svg>
Archives</a></li><li><a href=/categories><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>
Categories</a></li><li><a href=/tags><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg>
Tags</a></li><li><button class=search-trigger aria-label=Search>
<svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>
Search</button></li></ul></nav></div></div></header><main class=main-content><div class=post-container><div class=container><article class=post-content><header class=post-header><h1 class=post-title>redis基础</h1><div class=post-meta><time datetime=2020-03-20><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2020-03-20
</time><a href=/categories/database class=category-link><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>
database
</a><span class=reading-time><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
4 min read
</span><span class=word-count><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>
716 words</span></div><div class=post-tags><a href=/tags/redis class=tag><svg class="icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg>
redis</a></div></header><div class=post-body><h2 id=redis介绍>redis介绍</h2><p>Redis 是完全开源的，遵守 BSD 协议，是一个高性能的 key-value 数据库。</p><p>Redis 与其他 key - value 缓存产品有以下三个特点：</p><ul><li>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li><li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li><li>Redis支持数据的备份，即master-slave模式的数据备份。</li></ul><h3 id=redis的安装>redis的安装</h3><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>brew install redis<span style=color:#f92672>(</span>mac<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>yum install redis<span style=color:#f92672>(</span>centos<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>apt-get install redis<span style=color:#f92672>(</span>ubuntu<span style=color:#f92672>)</span>
</span></span></code></pre></div><h2 id=redis的命令网站>redis的命令网站</h2><p><a href=http://doc.redisfans.com/>Redis 命令参考 — Redis 命令参考 (redisfans.com)</a></p><h2 id=redis的基本操作>redis的基本操作</h2><h3 id=redis的五大数据类型>redis的五大数据类型</h3><p>redis的五大数据类型是: <strong>String(字符串)、Hash(哈希)、List(列表)、Set(集合)、和zset(sorted set:有序集合)</strong></p><h3 id=redis键操作>redis键操作</h3><ul><li><code>keys *</code>查看当前库所有key (匹配：keys *1)</li><li><code>exists key</code>判断某个key是否存在</li><li><code>type key</code> 查看你的key是什么类型</li><li><code>del key</code> 删除指定的key数据</li><li><code>unlink key</code> 根据value选择非阻塞删除 仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。</li><li><code>expire key 10 </code>10秒钟：为给定的key设置过期时间</li><li><code>ttl key</code> 查看还有多少秒过期，-1表示永不过期，-2表示已过期</li><li><code>select</code>命令切换数据库</li><li><code>dbsize</code>查看当前数据库的key的数量</li><li><code>flushdb</code>清空当前库</li><li><code>flushall</code>通杀全部库</li></ul><h3 id=字符串string>字符串(String)</h3><h4 id=简介>简介</h4><p>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</p><p>String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</p><p>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</p><h4 id=常用命令>常用命令</h4><ul><li><code>set &lt;key>&lt;value></code>添加键值对</li><li><code>get &lt;key></code>查询对应键值</li><li><code>append &lt;key>&lt;value></code>将给定的<value> 追加到原值的末尾</li><li><code>strlen &lt;key></code>获得值的长度</li><li><code>setnx &lt;key>&lt;value></code>只有在 key 不存在时 设置 key 的值</li><li><code>incr &lt;key> </code>将 key 中储存的数字值增1 只能对数字值操作，如果为空，新增值为1</li><li><code>decr &lt;key></code> 将 key 中储存的数字值减1 只能对数字值操作，如果为空，新增值为-1</li><li><code>incrby / decrby &lt;key>&lt;步长></code>将 key 中储存的数字值增减。自定义步长。</li></ul><h4 id=数据结构>数据结构</h4><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.</p><p><img src=/images/f5606772-f15c-49ef-9c08-6b7f1e6495ea.png alt></p><p>如图中所示，内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。</p><h3 id=列表list>列表(List)</h3><h4 id=简介-1>简介</h4><p>单键多值</p><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><p>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p><p><img src=/images/e7492d9c-c6d9-4de0-83b5-fd6482bc3c51.png alt></p><h4 id=常用命令-1>常用命令</h4><ul><li><code>lpush/rpush &lt;key>&lt;value1>&lt;value2>&lt;value3> ....</code> 从左边/右边插入一个或多个值。</li><li><code>lpop/rpop &lt;key></code>从左边/右边吐出一个值。值在键在，值光键亡。</li><li><code>rpoplpush &lt;key1>&lt;key2></code>从<key1>列表右边吐出一个值，插到<key2>列表左边。</li><li><code>lrange &lt;key>&lt;start>&lt;stop></code> 按照索引下标获得元素(从左到右)</li><li><code>lrange mylist 0 -1</code> 0左边第一个，-1右边第一个，（0-1表示获取所有）</li><li><code>lindex &lt;key>&lt;index></code>按照索引下标获得元素(从左到右)</li><li><code>llen &lt;key></code>获得列表长度</li><li><code>linsert &lt;key> before &lt;value>&lt;newvalue></code>在<value>的后面插入<newvalue>插入值</li><li><code>lrem &lt;key>&lt;n>&lt;value></code>从左边删除n个value(从左到右)</li><li><code>lset&lt;key>&lt;index>&lt;value></code>将列表key下标为index的值替换成value</li></ul><h4 id=数据结构-1>数据结构</h4><p>List的数据结构为快速链表quickList。</p><p>首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p><p><img src=/images/810b0d87-7a3c-416a-87ac-66ad441e8a0a.png alt></p><p>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><h3 id=集合set>集合(Set)</h3><h4 id=简介-2>简介</h4><p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以****自动排重****的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。</p><p>Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的****复杂度都是O(1)****。</p><p>一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变</p><h4 id=常用命令-2>常用命令</h4><ul><li><code>sadd &lt;key>&lt;value1>&lt;value2> ..... </code>将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</li><li><code>smembers &lt;key></code>取出该集合的所有值。</li><li><code>sismember &lt;key>&lt;value></code>判断集合<key>是否为含有该<value>值，有1，没有0</li><li><code>scard&lt;key></code>返回该集合的元素个数。</li><li><code>srem &lt;key>&lt;value1>&lt;value2> ....</code> 删除集合中的某个元素。</li><li><code>spop &lt;key></code><em><strong>*随机从该集合中吐出一个值。*</strong></em></li><li><code>srandmember &lt;key>&lt;n></code>随机从该集合中取出n个值。不会从集合中删除 。</li><li><code>smove &lt;source>&lt;destination></code>value把集合中一个值从一个集合移动到另一个集合</li><li><code>sinter &lt;key1>&lt;key2></code>返回两个集合的交集元素。</li><li><code>sunion &lt;key1>&lt;key2></code>返回两个集合的并集元素。</li><li><code>sdiff &lt;key1>&lt;key2></code>返回两个集合的****差集****元素(key1中的，不包含key2中的)</li></ul><h4 id=数据结构-2>数据结构</h4><p>Set数据结构是dict字典，字典是用哈希表实现的。
Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p><h3 id=哈希hash>哈希(Hash)</h3><h4 id=简介-3>简介</h4><p>Redis hash 是一个键值对集合。</p><p>Redis hash是一个string类型的field和value的映射表，hash特别适合用于存储对象。</p><h4 id=常用命令-3>常用命令</h4><ul><li><code>hset &lt;key>&lt;field>&lt;value></code>给<key>集合中的 <field>键赋值<value></li><li><code>hget &lt;key1>&lt;field></code>从<key1>集合<field>取出 value</li><li><code>hmset &lt;key1>&lt;field1>&lt;value1>&lt;field2>&lt;value2>... </code>批量设置hash的值</li><li><code>hexists&lt;key1>&lt;field></code>查看哈希表 key 中，给定域 field 是否存在。</li><li><code>hkeys &lt;key></code>列出该hash集合的所有field</li><li><code>hvals &lt;key></code>列出该hash集合的所有value</li><li><code>hincrby &lt;key>&lt;field>&lt;increment></code>为哈希表 key 中的域 field 的值加上增量 1 -1</li><li><code>hsetnx &lt;key>&lt;field>&lt;value></code>将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 .</li></ul><h4 id=数据结构-3>数据结构</h4><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p><h3 id=有序集合zsetsorted-set>有序集合Zset(sorted set)</h3><h4 id=简介-4>简介</h4><p>Redis有序集合zset与普通集合set非常相似，是一个没有重复元素的字符串集合。</p><p>不同之处是有序集合的每个成员都关联了一个****评分（score）****,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。</p><p>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p><p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p><h4 id=常用命令-4>常用命令</h4><ul><li><code>zadd &lt;key>&lt;score1>&lt;value1>&lt;score2>&lt;value2>… </code>将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</li><li><code>zrange &lt;key>&lt;start>&lt;stop> [WITHSCORES] </code>返回有序集 key 中，下标在<start><stop>之间的元素带WITHSCORES，可以让分数一起和值返回到结果集。</li><li><code>zrangebyscore key minmax [withscores] [limit offset count]</code> 返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。</li><li><code>zrevrangebyscore key maxmin [withscores] [limit offset count] </code>同上，改为从大到小排列。</li><li><code>zincrby &lt;key>&lt;increment>&lt;value></code> 为元素的score加上增量</li><li><code>zrem &lt;key>&lt;value></code>删除该集合下，指定值的元素</li><li><code>zcount &lt;key>&lt;min>&lt;max></code>统计该集合，分数区间内的元素个数</li><li><code>zrank &lt;key>&lt;value></code>返回该值在集合中的排名，从0开始。</li></ul><h4 id=数据结构-4>数据结构</h4><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double>，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p><p>zset底层使用了两个数据结构</p><ol><li>hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</li><li>跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</li></ol><h2 id=redis新数据类型>Redis新数据类型</h2><h3 id=bitmaps>Bitmaps</h3><h4 id=简介-5>简介</h4><p>现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011，如下图</p><p><img src=/images/4ba572ec-0cd0-471d-8321-46012e72f259.png alt></p><p>合理地使用操作位能够有效地提高内存使用率和开发效率。</p><p>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p><ol><li>Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</li><li>Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</li></ol><p><img src=/images/38fcab8e-c732-4d37-9712-712a307f36d1.png alt></p><h4 id=命令>命令</h4><ol><li>setbit</li></ol><p>（1）格式</p><p><code>setbit&lt;key>&lt;offset>&lt;value></code>设置Bitmaps中某个偏移量的值（0或1）</p><p><img src=/images/82e8f396-ad55-40db-b4b5-6dc9201c6e33.png alt></p><p>*offset:偏移量从0开始</p><p>（2）实例</p><p>每个独立用户是否访问过网站存放在Bitmaps中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的id。</p><p>设置键的第offset个位的值（从0算起） ， 假设现在有20个用户，userid=1， 6， 11， 15， 19的用户对网站进行了访问， 那么当前Bitmaps初始化结果如图</p><p><img src=/images/b881197f-9c5a-44f1-a9ec-2f68364ca122.png alt></p><p>unique:users:20201106代表2020-11-06这天的独立访问用户的Bitmaps</p><p><img src=/images/906ce509-1af2-45c6-9238-4ba96f69eef0.png alt></p><p>注：</p><p>很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。</p><p>在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。</p><ol start=2><li>getbit</li></ol><p>（1）格式
getbit<key><offset>获取Bitmaps中某个偏移量的值</p><p>获取键的第offset位的值（从0开始算）</p><p>（2）实例
获取id=8的用户是否在2020-11-06这天访问过， 返回0说明没有访问过</p><p><img src=/images/7585a845-40ec-4482-8c9f-03e904de86f1.png alt></p><p>注：因为100根本不存在，所以也是返回0</p><ol start=3><li>bitcount</li></ol><p>统计字符串被设置为1的bit数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。
（1）格式
bitcount<key>[start end] 统计字符串从start字节到end字节比特值为1的数量</p><p>（2）实例
计算2022-11-06这天的独立访问用户数量</p><p>start和end代表起始和结束字节数， 下面操作计算用户id在第1个字节到第3个字节之间的独立访问用户数， 对应的用户id是11， 15， 19。</p><pre tabindex=0><code>举例： K1 【01000001 01000000  00000000 00100001】，对应【0，1，2，3】
bitcount K1 1 2  ： 统计下标1、2字节组中bit=1的个数，即01000000  00000000
--》bitcount K1 1 2 　　--》1

bitcount K1 1 3  ： 统计下标1、2字节组中bit=1的个数，即01000000  00000000 00100001
--》bitcount K1 1 3　　--》3

bitcount K1 0 -2  ： 统计下标0到下标倒数第2，字节组中bit=1的个数，即01000001  01000000   00000000
--》bitcount K1 0 -2　　--》3
</code></pre><p>注意：redis的setbit设置或清除的是bit位置，而bitcount计算的是byte位置。</p><ol start=4><li>bitop</li></ol><p>(1)格式
bitop and(or/not/xor) <destkey>[key…]</p><p><img src=/images/8a7cd908-8bf4-4a7e-8811-9c572487fea9.png alt></p><p>bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。</p><p>(2)实例</p><p>2020-11-04 日访问网站的userid=1,2,5,9。</p><p>setbit unique:users:20201104 1 1</p><p>setbit unique:users:20201104 2 1</p><p>setbit unique:users:20201104 5 1</p><p>setbit unique:users:20201104 9 1</p><p>2020-11-03 日访问网站的userid=0,1,4,9。</p><p>setbit unique:users:20201103 0 1</p><p>setbit unique:users:20201103 1 1</p><p>setbit unique:users:20201103 4 1</p><p>setbit unique:users:20201103 9 1</p><p>计算出两天都访问过网站的用户数量</p><p>bitop and unique:users:and:20201104_03</p><p>unique:users:20201103unique:users:20201104</p><p><img src=/images/06377b31-60a0-455e-97c8-7febdf1a07ea.png alt></p><p><img src=/images/7ee5ed4d-b2bd-43d4-b7a7-5c26c7562a28.png alt></p><p>计算出任意一天都访问过网站的用户数量（例如月活跃就是类似这种） ， 可以使用or求并集</p><p><img src=/images/0a8dfb0f-51f5-4caa-a615-0304b5f4bbf9.png alt></p><h4 id=bitmaps与set对比>Bitmaps与set对比</h4><p>假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表</p><table><thead><tr><th>set和Bitmaps存储一天活跃用户对比</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据类型</td><td>每个用户id占用空间</td><td>需要存储的用户量</td><td>全部内存量</td></tr><tr><td>集合类型</td><td>64位</td><td>50000000</td><td>64位*50000000 = 400MB</td></tr><tr><td>Bitmaps</td><td>1位</td><td>100000000</td><td>1位*100000000 = 12.5MB</td></tr></tbody></table><p>很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的</p><table><thead><tr><th>set和Bitmaps存储独立用户空间对比</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据类型</td><td>一天</td><td>一个月</td><td>一年</td></tr><tr><td>集合类型</td><td>400MB</td><td>12GB</td><td>144GB</td></tr><tr><td>Bitmaps</td><td>12.5MB</td><td>375MB</td><td>4.5GB</td></tr></tbody></table><p>但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0。</p><table><thead><tr><th>set和Bitmaps存储一天活跃用户对比（独立用户比较少）</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>数据类型</td><td>每个userid占用空间</td><td>需要存储的用户量</td><td>全部内存量</td></tr><tr><td>集合类型</td><td>64位</td><td>100000</td><td>64位*100000 = 800KB</td></tr><tr><td>Bitmaps</td><td>1位</td><td>100000000</td><td>1位*100000000 = 12.5MB</td></tr></tbody></table><h3 id=hyperloglog>HyperLogLog</h3><h4 id=简介-6>简介</h4><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。
但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。
解决基数问题有很多种方案：
（1）数据存储在MySQL表中，使用distinct count计算不重复个数</p><p>（2）使用Redis提供的hash、set、bitmaps等数据结构来处理</p><p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。</p><p>能否能够降低一定的精度来平衡存储空间？Redis推出了HyperLogLog</p><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><p>什么是基数?</p><p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p><h4 id=命令-1>命令</h4><p>1、pfadd</p><p>（1）格式</p><p>pfadd <key>&lt; element> [element &mldr;] 添加指定元素到 HyperLogLog 中</p><p><img src=/images/62e21699-dc0f-46bd-82cb-029f3222fbc7.png alt></p><p>（2）实例</p><p><img src=/images/c2f7d56a-b3f5-4a35-9b22-d974527449b0.png alt></p><p>​ 将所有元素添加到指定HyperLogLog数据结构中。如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0。</p><p>2、pfcount</p><p>（1）格式</p><p>pfcount<key> [key &mldr;] 计算HLL的近似基数，可以计算多个HLL，比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可</p><p><img src=/images/f809026c-fc64-48fe-be04-706e6cc41f44.png alt></p><p>（2）实例</p><p><img src=/images/f5b58b59-9932-4057-bd8f-60432b157770.png alt></p><p>3、pfmerge</p><p>（1）格式</p><p>pfmerge<destkey><sourcekey> [sourcekey &mldr;] 将一个或多个HLL合并后的结果存储在另一个HLL中，比如每月活跃用户可以使用每天的活跃用户来合并计算可得</p><p><img src=/images/631183a5-9ff4-48b7-ac89-fbdd7789d129.png alt></p><p>（2）实例</p><p><img src=/images/dfd3ee89-78e6-42ce-a229-dc9cefd1cec4.png alt></p><h3 id=geospatial>Geospatial</h3><h4 id=简介-7>简介</h4><p>Redis 3.2 中增加了对GEO类型的支持。GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p><h4 id=命令-2>命令</h4><p>1、geoadd</p><p>（1）格式</p><p>geoadd<key>&lt; longitude><latitude><member> [longitude latitude member&mldr;] 添加地理位置（经度，纬度，名称）</p><p><img src=/images/05ef798c-3889-4c03-91d4-90b1f15c9956.png alt></p><p>2）实例</p><p>geoadd china:city 121.47 31.23 shanghai</p><p>geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing</p><p><img src=/images/8ac8b0f3-9cfb-40e5-9cb9-8ef5b49ec1b6.png alt></p><p>两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。</p><p>有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。</p><p>当坐标位置超出指定范围时，该命令将会返回一个错误。</p><p>已经添加的数据，是无法再次往里面添加的。</p><p>2、geopos</p><p>（1）格式</p><p>geopos <key><member>[member&mldr;] 获得指定地区的坐标值</p><p><img src=/images/d0233779-9639-4787-8e99-3283ac7e855e.png alt></p><p>（2）实例</p><p><img src=/images/71ab3c6c-66ca-4a71-b6d2-f16555a3e548.png alt></p><p>3、geodist</p><p>（1）格式</p><p>geodist<key><member1><member2> [m|km|ft|mi ] 获取两个位置之间的直线距离</p><p><img src=/images/ed4cb462-5939-4c09-9392-bd6c6b50dec6.png alt></p><p>（2）实例</p><p>获取两个位置之间的直线距离</p><p><img src=/images/c5817ee3-a137-430a-9734-c3a51179382f.png alt></p><p>单位：</p><p>m 表示单位为米[默认值]。</p><p>km 表示单位为千米。</p><p>mi 表示单位为英里。</p><p>ft 表示单位为英尺。</p><p>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位</p><p>4、georadius</p><p>（1）格式</p><p>georadius<key>&lt; longitude><latitude>radius m|km|ft|mi 以给定的经纬度为中心，找出某一半径内的元素</p><p><img src=/images/63d0253a-d296-4b59-9b3a-0cda8db7167f.png alt></p><p>经度 纬度 距离 单位</p><p>（2）实例</p><p><img src=/images/bd56b575-3eab-442e-aa42-fb8768d47bb1.png alt></p></div><footer class=post-footer><div class=post-license><p><strong>Article Title:</strong> redis基础</p><p><strong>Author:</strong> daemon365</p><p><strong>Permalink:</strong> <a href=https://daemon365.dev/post/database/redis_basics/>https://daemon365.dev/post/database/redis_basics/</a></p><p><strong>License:</strong> This article is licensed under
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank rel=noopener>BY-NC-SA</a>. Please cite the source when reposting.</p></div><nav class=post-navigation><a href=/post/cloud/introduction_to_nginx__usage/ class=nav-prev><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></svg><div><span class=nav-label>Previous</span>
<span class=nav-title>nginx简介,使用</span></div></a><a href=/post/database/redis_persistence/ class=nav-next><div><span class=nav-label>Next</span>
<span class=nav-title>redis持久化</span></div><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg></a></nav><div class=post-comments><script src=https://utteranc.es/client.js repo=daemon365/blog issue-term=pathname label=comments theme=preferred-color-scheme crossorigin=anonymous async></script></div></footer></article></div></div><div class=toc-float-button id=tocButton><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 19.5A2.5 2.5.0 016.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5.0 014 19.5v-15A2.5 2.5.0 016.5 2z"/></svg></div><div class=toc-panel id=tocPanel><div class=toc-panel-header><h3 class=toc-panel-title>Table of Contents</h3><button class=toc-panel-close id=tocClose>
<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button></div><nav class=toc-panel-nav id=TableOfContents><nav id=TableOfContents><ul><li><a href=#redis介绍>redis介绍</a><ul><li><a href=#redis的安装>redis的安装</a></li></ul></li><li><a href=#redis的命令网站>redis的命令网站</a></li><li><a href=#redis的基本操作>redis的基本操作</a><ul><li><a href=#redis的五大数据类型>redis的五大数据类型</a></li><li><a href=#redis键操作>redis键操作</a></li><li><a href=#字符串string>字符串(String)</a><ul><li><a href=#简介>简介</a></li><li><a href=#常用命令>常用命令</a></li><li><a href=#数据结构>数据结构</a></li></ul></li><li><a href=#列表list>列表(List)</a><ul><li><a href=#简介-1>简介</a></li><li><a href=#常用命令-1>常用命令</a></li><li><a href=#数据结构-1>数据结构</a></li></ul></li><li><a href=#集合set>集合(Set)</a><ul><li><a href=#简介-2>简介</a></li><li><a href=#常用命令-2>常用命令</a></li><li><a href=#数据结构-2>数据结构</a></li></ul></li><li><a href=#哈希hash>哈希(Hash)</a><ul><li><a href=#简介-3>简介</a></li><li><a href=#常用命令-3>常用命令</a></li><li><a href=#数据结构-3>数据结构</a></li></ul></li><li><a href=#有序集合zsetsorted-set>有序集合Zset(sorted set)</a><ul><li><a href=#简介-4>简介</a></li><li><a href=#常用命令-4>常用命令</a></li><li><a href=#数据结构-4>数据结构</a></li></ul></li></ul></li><li><a href=#redis新数据类型>Redis新数据类型</a><ul><li><a href=#bitmaps>Bitmaps</a><ul><li><a href=#简介-5>简介</a></li><li><a href=#命令>命令</a></li><li><a href=#bitmaps与set对比>Bitmaps与set对比</a></li></ul></li><li><a href=#hyperloglog>HyperLogLog</a><ul><li><a href=#简介-6>简介</a></li><li><a href=#命令-1>命令</a></li></ul></li><li><a href=#geospatial>Geospatial</a><ul><li><a href=#简介-7>简介</a></li><li><a href=#命令-2>命令</a></li></ul></li></ul></li></ul></nav></nav></div></main><footer class=site-footer><div class=container><div class=footer-content><div class=footer-info><p class=copyright>© 2025 daemon365</p><p class=powered-by>Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/daemon365/hugo-theme-daemon target=_blank rel=noopener>Daemon</a></p></div><div class=social-links><a href=https://github.com/daemon365 target=_blank rel=noopener aria-label=GitHub><svg class="icon" width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0C5.374.0.0 5.373.0 12c0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931.0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176.0.0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221.0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576C20.566 21.797 24 17.3 24 12c0-6.627-5.373-12-12-12z"/></svg>
</a><a href=mailto:daemon365@foxmail.com aria-label=Email><svg class="icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></div></div></div></footer><div class=search-modal id=searchModal><div class=search-modal-backdrop></div><div class=search-modal-content><div class=search-modal-header><input type=text class=search-input id=searchInput placeholder="Search articles..." autofocus>
<button class=search-close aria-label="Close search">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button></div><div class=search-results id=searchResults><p class=search-hint>Enter 2 or more characters to start searching</p></div></div></div><script src=/js/components/search.js></script><script src=/js/components/toc.js></script><script src=/js/components/scroll-effects.js></script><script src=/js/components/code-copy.js></script><script src=/js/components/lazy-loading.js></script><script src=/js/components/image-preview.js></script><script src=/js/components/back-to-top.js></script><script src=/js/main-new.js></script><script>"serviceWorker"in navigator&&window.addEventListener("load",()=>{navigator.serviceWorker.register("/sw.js").then(e=>{console.log("Service Worker registered:",e.scope)}).catch(e=>{console.log("Service Worker registration failed:",e)})})</script></body></html>