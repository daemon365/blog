<!doctype html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.139.3"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/favicon.ico><meta itemprop=name content="从源码分析 GMP 调度原理"><meta itemprop=description content="Don't let yourself stop."><meta name=description content="Don't let yourself stop."><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://daemon365.dev/imgs/daemon365.png"><meta itemprop=keywords content="Go, Golang, Linux, Docker, Kubernetes, DevOps, Cloud Native, Open Source, Daemon365"><meta property="og:type" content="article"><meta property="og:title" content="从源码分析 GMP 调度原理"><meta property="og:description" content="Don't let yourself stop."><meta property="og:image" content="/imgs/daemon365.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://daemon365.dev/post/go/gmp_code/"><meta property="og:site_name" content="Daemon"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="daemon365"><meta property="article:published_time" content="2024-12-07 14:23:31 +0800 +0800"><meta property="article:modified_time" content="2024-12-07 14:23:31 +0800 +0800"><link type=text/css rel=stylesheet href=https://daemon365.dev/3rd/font-awesome/6.6.0/css/all.min.css><link type=text/css rel=stylesheet href=https://daemon365.dev/3rd/animate.css/4.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://daemon365.dev/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href=/css/main.min.5ec1f63635756d664e619fe2d87a11c7394f519beff240c124743433c9861792.css><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":true,"isHome":false,"isPage":true,"path":"gmp_code","permalink":"https://daemon365.dev/post/go/gmp_code/","title":"从源码分析 GMP 调度原理","waline":{"js":[{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"2.15.8"},{"alias":"@waline/client","alias_name":"waline","file":"dist/comment.js","name":"comment","version":"2.15.8"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.id="LA_COLLECT",e.src="https://sdk.51.la/js-sdk-pro.min.js",e.async="true",e.onload=function(){LA.init({id:"JmAHxEAUVgyS8B1c",ck:"JmAHxEAUVgyS8B1c",autoTrack:!0})},document.head.appendChild(e)})</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>从源码分析 GMP 调度原理 - Daemon</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Daemon</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>Don't let yourself stop.</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>Home</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>About</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>Archives</a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>Commonweal</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#传统-os-线程>传统 OS 线程</a></li><li><a href=#gmp-模型>GMP 模型</a></li><li><a href=#数据结构>数据结构</a><ul><li><a href=#g>G</a><ul><li><a href=#goroutine-状态>goroutine 状态</a></li></ul></li><li><a href=#m>M</a></li><li><a href=#p>P</a></li></ul></li><li><a href=#调度>调度</a><ul><li><a href=#主动调度>主动调度</a></li><li><a href=#阻塞调度>阻塞调度</a></li><li><a href=#抢占调度>抢占调度</a></li><li><a href=#调度代码>调度代码</a></li><li><a href=#syscall>syscall</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=daemon365 src=/imgs/img-lazy-loading.gif data-src=/imgs/daemon365.png><p class=site-author-name itemprop=name>daemon365</p><div class=site-description itemprop=description>Don't let yourself stop.</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>94</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>7</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>52</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/daemon365 title="Github → https://github.com/daemon365" rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>
Github</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://go-kratos.dev title=https://go-kratos.dev target=_blank>kratos</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script><script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://daemon365.dev/post/go/gmp_code/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/daemon365.png"><meta itemprop=name content="daemon365"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="daemon365"><meta itemprop=description content="Don't let yourself stop."></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="从源码分析 GMP 调度原理"><meta itemprop=description content="本身涉及到的 go 代码 都是基于 go 1.23.0 版本
传统 OS 线程

线程是 CPU 的最小调度单位，CPU 通过不断切换线程来实现多任务的并发。这会引发一些问题（对于用户角度）："></span><header class=post-header><h1 class=post-title itemprop="name headline">从源码分析 GMP 调度原理</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2024-12-07 14:23:31 +0800 +0800" itemprop="dateCreated datePublished" datetime="2024-12-07 14:23:31 +0800 +0800">2024-12-07
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/go itemprop=url rel=index><span itemprop=name>go</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="fas fa-solid fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>3101</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="fas fa-solid fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>7分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=busuanzi_value_page_pv data-path=/post/go/gmp_code/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p><strong>本身涉及到的 go 代码 都是基于 go 1.23.0 版本</strong></p><h2 id=传统-os-线程>传统 OS 线程
<a class=header-anchor href=#%e4%bc%a0%e7%bb%9f-os-%e7%ba%bf%e7%a8%8b></a></h2><p>线程是 CPU 的最小调度单位，CPU 通过不断切换线程来实现多任务的并发。这会引发一些问题（对于用户角度）：</p><ol><li>线程的创建和销毁等是昂贵的，因为要不断在用户空间和内核空间切换。</li><li>线程的调度是由操作系统负责的，用户无法控制。而操作系统又可能不知道线程已经 IO 阻塞，导致线程被调度，浪费 CPU 资源。</li><li>线程的栈是很大的，最新版 linux 默认是 8M，会引起内存浪费。</li><li>&mldr;&mldr;</li></ol><p>所以，最简单的办法就是复用线程，go 中使用的是 M:N 模型，即 M 个 OS 线程对应 N 个 任务。</p><h2 id=gmp-模型>GMP 模型
<a class=header-anchor href=#gmp-%e6%a8%a1%e5%9e%8b></a></h2><ol><li>G</li></ol><p>goroutine, 一个 goroutine 代表一个任务。它有自己的栈空间，默认是 2K，栈空间可以动态增长。方式就是把旧的栈空间复制到新的栈空间，然后释放旧的栈空间。它的栈是在 heap （对于 OS） 上分配的。</p><ol start=2><li>M</li></ol><p>machine, 一个 M 代表一个 OS 线程。</p><ol start=3><li>P</li></ol><p>processor, 一个 P 代表一个逻辑处理器，它维护了一个 goroutine 队列。P 会把 goroutine 分配给 M，M 会执行 goroutine。默认的大小为 CPU 核心数。</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/gmp.png alt></p><h2 id=数据结构>数据结构
<a class=header-anchor href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84></a></h2><h3 id=g>G
<a class=header-anchor href=#g></a></h3><p>结构体在 <code>src/runtime/runtime2.go</code> 中定义，主要介绍一些重要的字段：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>g</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// goroutine 的栈 两个地址，分别是栈的起始地址和结束地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>stack</span>       <span style=color:#a6e22e>stack</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 绑定的m
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>m</span>         <span style=color:#f92672>*</span><span style=color:#a6e22e>m</span> 
</span></span><span style=display:flex><span>  <span style=color:#75715e>// goroutine 被调度走保存的中间状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>sched</span>     <span style=color:#a6e22e>gobuf</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// goroutine 的状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>atomicstatus</span> <span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Uint32</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>gobuf</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>sp</span>   <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// stack pointer 栈指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>pc</span>   <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// program counter 程序要从哪里开始执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>g</span>    <span style=color:#a6e22e>guintptr</span> <span style=color:#75715e>// goroutine 的 指针
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>ctxt</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span> <span style=color:#75715e>// 保存的上下文
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>ret</span>  <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// 返回地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>lr</span>   <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// link register
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>bp</span>   <span style=color:#66d9ef>uintptr</span> <span style=color:#75715e>// base pointer 栈的基地址
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h4 id=goroutine-状态>goroutine 状态
<a class=header-anchor href=#goroutine-%e7%8a%b6%e6%80%81></a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// defined constants
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> (
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 未初始化
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_Gidle</span> = <span style=color:#66d9ef>iota</span> <span style=color:#75715e>// 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 准备好了 可以被 P 调度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_Grunnable</span> <span style=color:#75715e>// 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 正在执行中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_Grunning</span> <span style=color:#75715e>// 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 正在执行系统调用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_Gsyscall</span> <span style=color:#75715e>// 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 正在等待 例如 channel network 等
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_Gwaiting</span> <span style=color:#75715e>// 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 没有被使用 为了兼容性
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_Gmoribund_unused</span> <span style=color:#75715e>// 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 未使用的 goroutine 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 1. 可能初始化了但是没有被使用 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 2. 因为会复用未扩栈的 goroutine 所以也可能上次使用完了 还没继续使用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_Gdead</span> <span style=color:#75715e>// 6
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 没有被使用 为了兼容性
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_Genqueue_unused</span> <span style=color:#75715e>// 7
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 栈扩容中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_Gcopystack</span> <span style=color:#75715e>// 8
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 被抢占了 等待到 _Gwaiting 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_Gpreempted</span> <span style=color:#75715e>// 9
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 用于 GC 扫描
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_Gscan</span>          = <span style=color:#ae81ff>0x1000</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>_Gscanrunnable</span>  = <span style=color:#a6e22e>_Gscan</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>_Grunnable</span>  <span style=color:#75715e>// 0x1001
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_Gscanrunning</span>   = <span style=color:#a6e22e>_Gscan</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>_Grunning</span>   <span style=color:#75715e>// 0x1002
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_Gscansyscall</span>   = <span style=color:#a6e22e>_Gscan</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>_Gsyscall</span>   <span style=color:#75715e>// 0x1003
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_Gscanwaiting</span>   = <span style=color:#a6e22e>_Gscan</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>_Gwaiting</span>   <span style=color:#75715e>// 0x1004
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_Gscanpreempted</span> = <span style=color:#a6e22e>_Gscan</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>_Gpreempted</span> <span style=color:#75715e>// 0x1009
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>)
</span></span></code></pre></div><p>状态流转:</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/gmp_g_status.png.png alt></p><ol><li>如果 groutine 还未初始化，那么状态是 <code>_Gidle</code></li><li>初始化完毕是 <code>_Gdead</code></li><li>当被调用 go func() 时，状态变为 <code>_Grunnable</code></li><li>当被调度到 M 上执行时，状态变为 <code>_Grunning</code></li><li>执行完毕后，状态变为 <code>_Gdead</code></li><li>如果 goroutine 阻塞，状态变为 <code>_Gwaiting</code> 等待阻塞完毕 状态再变为 <code>_Grunnable</code> 等待调度</li><li>如果 goroutine 被抢占 （gc 要 STW 时），状态变为 <code>_Gpreempted</code> 等待变成 <code>_Gwaiting</code></li><li>如果发生系统调用，状态变为 <code>_Gsyscall</code> 如果很快完成（10ms） 状态会变为 <code>_Grunning</code> 继续执行 否则会变为 <code>_Grunnable</code> 等待调度</li><li>如果发生栈扩容，状态变为 <code>_Gcopystack</code> 等待栈扩容完毕 状态变为 <code>_Grunnable</code> 等待调度</li></ol><h3 id=m>M
<a class=header-anchor href=#m></a></h3><p>结构体在 <code>src/runtime/runtime2.go</code> 中定义，主要介绍一些重要的字段：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>m</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>g0</span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 寄存器上下文
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>morebuf</span> <span style=color:#a6e22e>gobuf</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// tls 是线程本地存储 用于存储 M 相关的线程本地数据 包括当前 G 的引用等重要信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>tls</span>           [<span style=color:#a6e22e>tlsSlots</span>]<span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 现在正在执行的 goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>curg</span>          <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span> 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 1. 正常执行： p 有效
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 2. 系统调用前： p -&gt; oldp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 3. 系统调用中： p == nil
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 4. 系统调用返回： 尝试重新获取 oldp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>p</span>             <span style=color:#a6e22e>puintptr</span> 
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>nextp</span>         <span style=color:#a6e22e>puintptr</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>oldp</span>          <span style=color:#a6e22e>puintptr</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>g0： 一个特殊的 g 用于执行调度任务 它未使用 go runtime 的 stack 而是使用 os stack
流程大概为用户态的 g -> g0 调度 -> 用户的其他 g</p><h3 id=p>P
<a class=header-anchor href=#p></a></h3><p>结构体在 <code>src/runtime/runtime2.go</code> 中定义，主要介绍一些重要的字段：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>p</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// p 的状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>status</span>      <span style=color:#66d9ef>uint32</span> 
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 分配内存使用 每个p 都有的目的是少加锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>mcache</span>      <span style=color:#f92672>*</span><span style=color:#a6e22e>mcache</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 定长的 queue 用于存储 goroutine
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>runqhead</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>runqtail</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>runq</span>     [<span style=color:#ae81ff>256</span>]<span style=color:#a6e22e>guintptr</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//  下个运行的 goroutine 主要用来快速调度 比如从 chan 读取数据，把 g 放到 runnext 中 当完成读取时 直接从 runnext 中取出来执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>runnext</span> <span style=color:#a6e22e>guintptr</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>状态：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>const</span> (
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 空闲
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_Pidle</span> = <span style=color:#66d9ef>iota</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 正在运行中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_Prunning</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 正在执行系统调用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_Psyscall</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// GC 停止
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_Pgcstop</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 死亡状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>_Pdead</span>
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><h2 id=调度>调度
<a class=header-anchor href=#%e8%b0%83%e5%ba%a6></a></h2><p>go 有三种进行到调度的方式：</p><ol><li>用户 goroutine 主动执行 runtime.Gosched() 会把当前 goroutine 放到队列中等待调度</li><li>用户 goroutine 阻塞，例如 channel 读写，网络 IO 等 会主动调用修改自己状态并切换到 g0 执行调度任务</li><li>go runtime 中有个 OS 线程 （名称是 sysmon） 检测到 goroutine 超时（上次执行到现在超过 10ms）那就会给线程发信号 使其切换到 g0 执行调度任务</li></ol><p><em><strong>为什么 sysmon 使用物理线程而不是 goroutine 呢？</strong></em></p><p>因为所有 p 上正在执行的 g 都阻塞住了 比如 <code>for {}</code> 那么其他的 g 永远无法执行了包括负责检测的 sysmon</p><h3 id=主动调度>主动调度
<a class=header-anchor href=#%e4%b8%bb%e5%8a%a8%e8%b0%83%e5%ba%a6></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Gosched</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>checkTimeouts</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mcall</span>(<span style=color:#a6e22e>gosched_m</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=阻塞调度>阻塞调度
<a class=header-anchor href=#%e9%98%bb%e5%a1%9e%e8%b0%83%e5%ba%a6></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>gopark</span>(<span style=color:#a6e22e>unlockf</span> <span style=color:#66d9ef>func</span>(<span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>) <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>lock</span> <span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>, <span style=color:#a6e22e>reason</span> <span style=color:#a6e22e>waitReason</span>, <span style=color:#a6e22e>traceReason</span> <span style=color:#a6e22e>traceBlockReason</span>, <span style=color:#a6e22e>traceskip</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>reason</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>waitReasonSleep</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>checkTimeouts</span>() <span style=color:#75715e>// timeouts may expire while two goroutines keep the scheduler busy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>acquirem</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>curg</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>status</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>readgstatus</span>(<span style=color:#a6e22e>gp</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>status</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>_Grunning</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>status</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>_Gscanrunning</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>throw</span>(<span style=color:#e6db74>&#34;gopark: bad g status&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>waitlock</span> = <span style=color:#a6e22e>lock</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>waitunlockf</span> = <span style=color:#a6e22e>unlockf</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>waitreason</span> = <span style=color:#a6e22e>reason</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>waitTraceBlockReason</span> = <span style=color:#a6e22e>traceReason</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>waitTraceSkip</span> = <span style=color:#a6e22e>traceskip</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>releasem</span>(<span style=color:#a6e22e>mp</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// can&#39;t do anything that might move the G between Ms here.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mcall</span>(<span style=color:#a6e22e>park_m</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=抢占调度>抢占调度
<a class=header-anchor href=#%e6%8a%a2%e5%8d%a0%e8%b0%83%e5%ba%a6></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// m 在 start 的时候会注册一些信号处理函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>initsig</span>(<span style=color:#a6e22e>preinit</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> uint32(<span style=color:#ae81ff>0</span>); <span style=color:#a6e22e>i</span> &lt; <span style=color:#a6e22e>_NSIG</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>setsig</span>(<span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>abi</span>.<span style=color:#a6e22e>FuncPCABIInternal</span>(<span style=color:#a6e22e>sighandler</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// sighandler -&gt; doSigPreempt -&gt; asyncPreempt （去汇编代码里找） -&gt; asyncPreempt2 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>asyncPreempt2</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getg</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>asyncSafePoint</span> = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>preemptStop</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>mcall</span>(<span style=color:#a6e22e>preemptPark</span>)
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>mcall</span>(<span style=color:#a6e22e>gopreempt_m</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>asyncSafePoint</span> = <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// sysmon 发信号 
</span></span></span><span style=display:flex><span><span style=color:#75715e>// sysmon -&gt; retake -&gt; preemptone -&gt; preemptM
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>preemptM</span>(<span style=color:#a6e22e>mp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>m</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>signalPending</span>.<span style=color:#a6e22e>CompareAndSwap</span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>signalM</span>(<span style=color:#a6e22e>mp</span>, <span style=color:#a6e22e>sigPreempt</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>signalM</span>(<span style=color:#a6e22e>mp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>m</span>, <span style=color:#a6e22e>sig</span> <span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>tgkill</span>(<span style=color:#a6e22e>getpid</span>(), int(<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>procid</span>), <span style=color:#a6e22e>sig</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 代码在在汇编里 就是对线程发送信号 系统调用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>tgkill</span>(<span style=color:#a6e22e>tgid</span>, <span style=color:#a6e22e>tid</span>, <span style=color:#a6e22e>sig</span> <span style=color:#66d9ef>int</span>)
</span></span></code></pre></div><h3 id=调度代码>调度代码
<a class=header-anchor href=#%e8%b0%83%e5%ba%a6%e4%bb%a3%e7%a0%81></a></h3><p>可以看到调度代码都是通过 mcall 调用的，mcall 会切换到 g0 执行调度任务 如果参数的函数不太一样 但是都是处理一些状态信息等，最好都会执行到 schedule 函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>schedule</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 核心代码就是选一个 g 去执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>inheritTime</span>, <span style=color:#a6e22e>tryWakeP</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>findRunnable</span>() <span style=color:#75715e>// blocks until work is available
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>execute</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>inheritTime</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>findRunnable：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>findRunnable</span>() (<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>inheritTime</span>, <span style=color:#a6e22e>tryWakeP</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Try to schedule a GC worker.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gcBlackenEnabled</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>tnow</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gcController</span>.<span style=color:#a6e22e>findRunnableGCWorker</span>(<span style=color:#a6e22e>pp</span>, <span style=color:#a6e22e>now</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>gp</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>now</span> = <span style=color:#a6e22e>tnow</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>schedtick</span><span style=color:#f92672>%</span><span style=color:#ae81ff>61</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>runqsize</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>globrunqget</span>(<span style=color:#a6e22e>pp</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>gp</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// local runq
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>inheritTime</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>runqget</span>(<span style=color:#a6e22e>pp</span>); <span style=color:#a6e22e>gp</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>inheritTime</span>, <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// global runq
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>runqsize</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>globrunqget</span>(<span style=color:#a6e22e>pp</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>gp</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>netpollinited</span>() <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>netpollAnyWaiters</span>() <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lastpoll</span>.<span style=color:#a6e22e>Load</span>() <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>list</span>, <span style=color:#a6e22e>delta</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>netpoll</span>(<span style=color:#ae81ff>0</span>); !<span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>empty</span>() { <span style=color:#75715e>// non-blocking
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>gp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>list</span>.<span style=color:#a6e22e>pop</span>()
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>injectglist</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>list</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>netpollAdjustWaiters</span>(<span style=color:#a6e22e>delta</span>)
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>trace</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>traceAcquire</span>()
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>_Gwaiting</span>, <span style=color:#a6e22e>_Grunnable</span>)
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>ok</span>() {
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>trace</span>.<span style=color:#a6e22e>GoUnpark</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>				<span style=color:#a6e22e>traceRelease</span>(<span style=color:#a6e22e>trace</span>)
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>gp</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Spinning Ms: steal work from other Ps.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// Limit the number of spinning Ms to half the number of busy Ps.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// This is necessary to prevent excessive CPU consumption when
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// GOMAXPROCS&gt;&gt;1 but the program parallelism is low.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>spinning</span> <span style=color:#f92672>||</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>*</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>nmspinning</span>.<span style=color:#a6e22e>Load</span>() &lt; <span style=color:#a6e22e>gomaxprocs</span><span style=color:#f92672>-</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>npidle</span>.<span style=color:#a6e22e>Load</span>() {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>spinning</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>mp</span>.<span style=color:#a6e22e>becomeSpinning</span>()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>inheritTime</span>, <span style=color:#a6e22e>tnow</span>, <span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>newWork</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>stealWork</span>(<span style=color:#a6e22e>now</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Successfully stole.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>inheritTime</span>, <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>newWork</span> {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// There may be new timer or GC work; restart to
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#75715e>// discover.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#66d9ef>goto</span> <span style=color:#a6e22e>top</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>now</span> = <span style=color:#a6e22e>tnow</span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>w</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#a6e22e>pollUntil</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>w</span> &lt; <span style=color:#a6e22e>pollUntil</span>) {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Earlier timer to wait for.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>pollUntil</span> = <span style=color:#a6e22e>w</span>
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>简化了一下代码还是很多 价绍一些这个功能吧</p><ol><li>优先执行 GC worker</li><li>每 61 次 从全局队列中获取一个 g 去执行 作用是 防止所有 p 的本地队列谁都非常多 导致全局队列的 g 饿死</li><li>从本地队列中获取一个 g 去执行 有限使用 runnext</li><li>从全局队列中获取一个 g 去执行 并 load 一些到本地队列</li><li>如果有网络 IO 准备好了 就从网络 IO 中获取一个 g 去执行 （go 中网络 epoll_wait 正常情况下使用的阻塞模式）</li><li>从其他的 p 中偷取 g 去执行 （cas 保证数据安全）</li></ol><p>execute：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>execute</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>inheritTime</span> <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 修改状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>_Grunnable</span>, <span style=color:#a6e22e>_Grunning</span>)
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>gogo</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>sched</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我的 arch 是 amd64 所以代码在 <code>src/runtime/asm_amd64.s</code> 中</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>TEXT</span> <span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>gogo</span>(<span style=color:#a6e22e>SB</span>), <span style=color:#a6e22e>NOSPLIT</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>buf</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>BX</span>	  <span style=color:#75715e>// 将 gobuf 指针加载到 BX 寄存器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>gobuf_g</span>(<span style=color:#a6e22e>BX</span>), <span style=color:#a6e22e>DX</span>  <span style=color:#75715e>// 将 gobuf 中保存的 g 指针加载到 DX
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>DX</span>), <span style=color:#a6e22e>CX</span>	  <span style=color:#75715e>// 检查 g 不为 nil
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>JMP</span>	<span style=color:#a6e22e>gogo</span>&lt;&gt;(<span style=color:#a6e22e>SB</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>TEXT</span> <span style=color:#a6e22e>gogo</span>&lt;&gt;(<span style=color:#a6e22e>SB</span>), <span style=color:#a6e22e>NOSPLIT</span>, <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>get_tls</span>(<span style=color:#a6e22e>CX</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>DX</span>, <span style=color:#a6e22e>g</span>(<span style=color:#a6e22e>CX</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>DX</span>, <span style=color:#a6e22e>R14</span>		<span style=color:#75715e>// set the g register
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// 恢复寄存器状态 （sp ret bp ctxt） 执行 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>gobuf_sp</span>(<span style=color:#a6e22e>BX</span>), <span style=color:#a6e22e>SP</span>	<span style=color:#75715e>// restore SP
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>gobuf_ret</span>(<span style=color:#a6e22e>BX</span>), <span style=color:#a6e22e>AX</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>gobuf_ctxt</span>(<span style=color:#a6e22e>BX</span>), <span style=color:#a6e22e>DX</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>gobuf_bp</span>(<span style=color:#a6e22e>BX</span>), <span style=color:#a6e22e>BP</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 加载之后 清空 go 的 gobuf 结构体 为了给 gc 节省压力
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>gobuf_sp</span>(<span style=color:#a6e22e>BX</span>)	
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>gobuf_ret</span>(<span style=color:#a6e22e>BX</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>gobuf_ctxt</span>(<span style=color:#a6e22e>BX</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>gobuf_bp</span>(<span style=color:#a6e22e>BX</span>)
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 跳转到保存的 PC （程序执行到哪了） 去执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>gobuf_pc</span>(<span style=color:#a6e22e>BX</span>), <span style=color:#a6e22e>BX</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>JMP</span>	<span style=color:#a6e22e>BX</span>
</span></span></code></pre></div><h3 id=syscall>syscall
<a class=header-anchor href=#syscall></a></h3><p>我的 arch 是 and64 操作系统是 linux 所以代码在 <code>src/runtime/asm_linux_amd64.s</code> 中</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>TEXT</span> <span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>SyscallNoError</span>(<span style=color:#a6e22e>SB</span>),<span style=color:#a6e22e>NOSPLIT</span>,<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span><span style=color:#f92672>-</span><span style=color:#ae81ff>48</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>CALL</span>	<span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>entersyscall</span>(<span style=color:#a6e22e>SB</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>a1</span><span style=color:#f92672>+</span><span style=color:#ae81ff>8</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>DI</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>a2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>16</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>SI</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>a3</span><span style=color:#f92672>+</span><span style=color:#ae81ff>24</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>DX</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>R10</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>R8</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>R9</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>trap</span><span style=color:#f92672>+</span><span style=color:#ae81ff>0</span>(<span style=color:#a6e22e>FP</span>), <span style=color:#a6e22e>AX</span>	<span style=color:#75715e>// syscall entry
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>SYSCALL</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>AX</span>, <span style=color:#a6e22e>r1</span><span style=color:#f92672>+</span><span style=color:#ae81ff>32</span>(<span style=color:#a6e22e>FP</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>MOVQ</span>	<span style=color:#a6e22e>DX</span>, <span style=color:#a6e22e>r2</span><span style=color:#f92672>+</span><span style=color:#ae81ff>40</span>(<span style=color:#a6e22e>FP</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>CALL</span>	<span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>exitsyscall</span>(<span style=color:#a6e22e>SB</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>RET</span>
</span></span></code></pre></div><p>系统调用前执行这个函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>entersyscall</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>getcallerfp</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>reentersyscall</span>(<span style=color:#a6e22e>getcallerpc</span>(), <span style=color:#a6e22e>getcallersp</span>(), <span style=color:#a6e22e>fp</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>reentersyscall</span>(<span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span>, <span style=color:#a6e22e>bp</span> <span style=color:#66d9ef>uintptr</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 保存寄存器信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>save</span>(<span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span>, <span style=color:#a6e22e>bp</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>syscallsp</span> = <span style=color:#a6e22e>sp</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>syscallpc</span> = <span style=color:#a6e22e>pc</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>syscallbp</span> = <span style=color:#a6e22e>bp</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 修改 g 状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>_Grunning</span>, <span style=color:#a6e22e>_Gsyscall</span>)
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>sysmonwait</span>.<span style=color:#a6e22e>Load</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>systemstack</span>(<span style=color:#a6e22e>entersyscall_sysmon</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>save</span>(<span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span>, <span style=color:#a6e22e>bp</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>().<span style=color:#a6e22e>runSafePointFn</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// runSafePointFn may stack split if run on this stack
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>systemstack</span>(<span style=color:#a6e22e>runSafePointFn</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>save</span>(<span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span>, <span style=color:#a6e22e>bp</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>syscalltick</span> = <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>().<span style=color:#a6e22e>syscalltick</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pp</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>()
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 解绑 P 和 M 并设置 oldP 为当前 P 等待系统调用之后重新绑定
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>m</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>oldp</span>.<span style=color:#a6e22e>set</span>(<span style=color:#a6e22e>pp</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>p</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 修改 P 的状态为 syscall
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>atomic</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>pp</span>.<span style=color:#a6e22e>status</span>, <span style=color:#a6e22e>_Psyscall</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>gcwaiting</span>.<span style=color:#a6e22e>Load</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>systemstack</span>(<span style=color:#a6e22e>entersyscall_gcwait</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>save</span>(<span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span>, <span style=color:#a6e22e>bp</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>locks</span><span style=color:#f92672>--</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>系统调用后执行这个函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>exitsyscall</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 如果之前保存的oldp不为空 那么重新绑定
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>exitsyscallfast</span>(<span style=color:#a6e22e>oldp</span>) {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// 设置状态为 runnable 并重新执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>_Gsyscall</span>, <span style=color:#a6e22e>_Grunning</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>disable</span>.<span style=color:#a6e22e>user</span> <span style=color:#f92672>&amp;&amp;</span> !<span style=color:#a6e22e>schedEnabled</span>(<span style=color:#a6e22e>gp</span>) {
</span></span><span style=display:flex><span>			<span style=color:#75715e>// Scheduling of this goroutine is disabled.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#a6e22e>Gosched</span>()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 切换到 g0 执行 exitsyscall0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>mcall</span>(<span style=color:#a6e22e>exitsyscall0</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>exitsyscall0</span>(<span style=color:#a6e22e>gp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>g</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 修改 g 状态到 _Grunnable 让重新可调度
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>casgstatus</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#a6e22e>_Gsyscall</span>, <span style=color:#a6e22e>_Grunnable</span>)
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 删除 gm 的绑定
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>dropg</span>()
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>lock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>	<span style=color:#75715e>// 找个空闲的 p （状态为 _Gidle） 与 M 绑定
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>pp</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>p</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>schedEnabled</span>(<span style=color:#a6e22e>gp</span>) {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>pp</span>, <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>pidleget</span>(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>locked</span> <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>pp</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果绑定失败了 直接把 g 放到全局队列中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>globrunqput</span>(<span style=color:#a6e22e>gp</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>locked</span> = <span style=color:#a6e22e>gp</span>.<span style=color:#a6e22e>lockedm</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>sysmonwait</span>.<span style=color:#a6e22e>Load</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 如果 sysmon 在等待 那么唤醒它
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>sysmonwait</span>.<span style=color:#a6e22e>Store</span>(<span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>notewakeup</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>sysmonnote</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>unlock</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sched</span>.<span style=color:#a6e22e>lock</span>)
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 如果找到 p 了 那么就去执行
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>pp</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>acquirep</span>(<span style=color:#a6e22e>pp</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>execute</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#66d9ef>false</span>) <span style=color:#75715e>// Never returns.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>locked</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Wait until another thread schedules gp and so m again.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// N.B. lockedm must be this M, as this g was running on this M
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// before entersyscall.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>stoplockedm</span>()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>execute</span>(<span style=color:#a6e22e>gp</span>, <span style=color:#66d9ef>false</span>) <span style=color:#75715e>// Never returns.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 如果没有 P 给我这个 M 绑定的话 那么把 M 休眠并加入到 schedlink 队列中  做复用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>stopm</span>()
</span></span><span style=display:flex><span>  <span style=color:#75715e>// 直到有新的 g 被调度到这个 M 上
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>schedule</span>() <span style=color:#75715e>// Never returns.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div></div><footer class=post-footer><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right alt=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
从源码分析 GMP 调度原理</li><li class=post-copyright-author><strong>本文作者： </strong>daemon365</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://daemon365.dev/post/go/gmp_code/ title="从源码分析 GMP 调度原理">https://daemon365.dev/post/go/gmp_code/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"></div><div class="post-nav-prev post-nav-item"><a href=/post/cloud/keepalived_haproxy/ rel=prev title="kube-apiserver 高可用，keepalived + haproxy">kube-apiserver 高可用，keepalived + haproxy
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=utterances-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2019 - 2024
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>daemon365</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.139.3 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.6.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://daemon365.dev/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://daemon365.dev/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":false,"save":"manual"},"copybtn":true,"darkmode":false,"hostname":"https://daemon365.dev/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lawidget":{"id":"JmAHxEAUVgyS8B1c","js":"https://v6-widget.51.la/v6/laId/quote.js?theme=0\u0026col=true\u0026f=12\u0026display=0,0,0,1,0,1,1,1"},"lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":false,"enable":false,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":true,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"utterances":{"cfg":{"issueterm":"pathname","label":"comments","repo":"daemon365/blog","theme":"preferred-color-scheme"},"js":"https://utteranc.es/client.js"},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://daemon365.dev/3rd"}},"version":"4.6.3"}</script><script type=text/javascript src=/js/main.min.412b2d7d9cead6dbf9b4df1d9dcc9b5b7818e8e434f664050b4498e888bb3009.js defer></script></body></html>