<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>golang GC 垃圾回收机制 - Daemon365</title><link rel=icon href=/imgs/favicon.ico><link rel=manifest href=/manifest.json><meta name=theme-color content="#007aff"><meta name=mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="default"><meta name=apple-mobile-web-app-title content="Daemon365"><meta name=description content="垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的对象，让出存储器资源，无需程序员手动执行。
Golang中的垃圾回收主要应用三色标记法，GC过程和其他用户goroutine可并发运行，但需要一定时间的STW(stop the world)，STW …"><meta name=keywords content="go"><meta name=author content="daemon365"><meta property="og:type" content="article"><meta property="og:url" content="https://daemon365.dev/post/go/golang_gc_garbage_collection_mechanism/"><meta property="og:title" content="golang GC 垃圾回收机制 - Daemon365"><meta property="og:description" content="垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的对象，让出存储器资源，无需程序员手动执行。
Golang中的垃圾回收主要应用三色标记法，GC过程和其他用户goroutine可并发运行，但需要一定时间的STW(stop the world)，STW …"><meta property="og:image" content="https://daemon365.dev/imgs/avatar.svg"><meta property="og:locale" content="en"><meta property="og:site_name" content="Daemon365"><meta property="article:published_time" content="2021-02-20T00:00:00+08:00"><meta property="article:modified_time" content="2021-02-20T00:00:00+08:00"><meta property="article:author" content="daemon365"><meta property="article:section" content="go"><meta property="article:tag" content="go"><meta name=twitter:card content="summary_large_image"><meta name=twitter:url content="https://daemon365.dev/post/go/golang_gc_garbage_collection_mechanism/"><meta name=twitter:title content="golang GC 垃圾回收机制 - Daemon365"><meta name=twitter:description content="垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的对象，让出存储器资源，无需程序员手动执行。
Golang中的垃圾回收主要应用三色标记法，GC过程和其他用户goroutine可并发运行，但需要一定时间的STW(stop the world)，STW …"><meta name=twitter:image content="https://daemon365.dev/imgs/avatar.svg"><link rel=canonical href=https://daemon365.dev/post/go/golang_gc_garbage_collection_mechanism/><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"golang GC 垃圾回收机制","description":"\u003cp\u003e垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的对象，让出存储器资源，无需程序员手动执行。\u003c\/p\u003e\n\u003cp\u003eGolang中的垃圾回收主要应用三色标记法，GC过程和其他用户goroutine可并发运行，但需要一定时间的\u003cstrong\u003eSTW(stop the world)\u003c\/strong\u003e，STW …\u003c\/p\u003e","datePublished":"2021-02-20T00:00:00\u002b08:00","dateModified":"2021-02-20T00:00:00\u002b08:00","author":{"@type":"Person","name":"daemon365"},"publisher":{"@type":"Organization","name":"Daemon365","logo":{"@type":"ImageObject","url":"https:\/\/daemon365.dev\/imgs\/favicon.ico"}},"mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/daemon365.dev\/post\/go\/golang_gc_garbage_collection_mechanism\/"},"inLanguage":"en"}</script><meta name=robots content="index, follow"><meta name=googlebot content="index, follow"><link rel=stylesheet href=/css/components/variables.css><link rel=stylesheet href=/css/components/base.css><link rel=stylesheet href=/css/components/layout.css><link rel=stylesheet href=/css/main.css><link rel=stylesheet href=/css/components/search.css><link rel=stylesheet href=/css/components/toc.css><link rel=stylesheet href=/css/components/image-preview.css><link rel=stylesheet href=/css/components/reading-progress.css><style>:root{font-family:-apple-system,BlinkMacSystemFont,segoe ui,Roboto,helvetica neue,Arial,sans-serif}</style></head><body><div class=reading-progress-bar></div><header class=site-header><div class=container><div class=header-content><div class=site-branding><a href=/ class=site-logo><span class=site-title>Daemon365</span></a></div><nav class=site-nav><ul class=nav-menu><li><a href=/><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 9l9-7 9 7v11a2 2 0 01-2 2H5a2 2 0 01-2-2z"/><polyline points="9 22 9 12 15 12 15 22"/></svg>
首页</a></li><li><a href=/about><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12.01" y2="8"/></svg>
关于</a></li><li><a href=/archives><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/></svg>
归档</a></li><li><a href=/categories><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>
分类</a></li><li><a href=/tags><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg>
标签</a></li><li><button class=search-trigger aria-label=Search>
<svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>
搜索</button></li></ul></nav></div></div></header><main class=main-content><div class=post-container><div class=container><article class=post-content><header class=post-header><h1 class=post-title>golang GC 垃圾回收机制</h1><div class=post-meta><time datetime=2021-02-20><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>
2021-02-20
</time><a href=/categories/go class=category-link><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg>
go
</a><span class=reading-time><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
2 min read
</span><span class=word-count><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/></svg>
330 words</span></div><div class=post-tags><a href=/tags/go class=tag><svg class="icon" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg>
go</a></div></header><div class=post-body><p>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的对象，让出存储器资源，无需程序员手动执行。</p><p>Golang中的垃圾回收主要应用三色标记法，GC过程和其他用户goroutine可并发运行，但需要一定时间的<strong>STW(stop the world)</strong>，STW的过程中，CPU不执行用户代码，全部用于垃圾回收，这个过程的影响很大，Golang进行了多次的迭代优化来解决这个问题。</p><h2 id=go-v13之前的标记-清除mark-and-sweep算法>Go V1.3之前的标记-清除(mark and sweep)算法</h2><p>此算法主要有两个主要的步骤：</p><ul><li>标记(Mark phase)</li><li>清除(Sweep phase)</li></ul><p><strong>第一步</strong>，暂停程序业务逻辑, 找出不可达的对象，然后做上标记。第二步，回收标记好的对象。</p><p>操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停！即 <code>STW(stop the world)</code>。也就是说，这段时间程序会卡在哪儿。</p><p><img src=/images/e7452cc0-956d-44ea-8ef6-22bad882f1d8.png alt></p><p><strong>第二步</strong>, 开始标记，程序找出它所有可达的对象，并做上标记。如下图所示：</p><p><img src=/images/a2d30455-7d6a-4039-8091-c369e405ce2b.png alt></p><p><strong>第三步</strong>, 标记完了之后，然后开始清除未标记的对象. 结果如下.</p><p><img src=/images/532f5acd-aac6-4a12-858c-4f79c7eeba24.png alt></p><p><strong>第四步</strong>, 停止暂停，让程序继续跑。然后循环重复这个过程，直到process程序生命周期结束。</p><h2 id=标记-清扫mark-and-sweep的缺点>标记-清扫(mark and sweep)的缺点</h2><ul><li>STW，stop the world；让程序暂停，程序出现卡顿 <strong>(重要问题)</strong>。</li><li>标记需要扫描整个heap</li><li>清除数据会产生heap碎片</li></ul><p>所以Go V1.3版本之前就是以上来实施的, 流程是</p><p><img src=/images/c24c6980-7fb9-4c34-8576-064bef2b2ba1.png alt></p><p>Go V1.3 做了简单的优化,将STW提前, 减少STW暂停的时间范围.如下所示</p><p><img src=/images/3cfb6c99-91b8-4693-9446-203000b2e3de.png alt></p><p><strong>这里面最重要的问题就是：mark-and-sweep 算法会暂停整个程序</strong> 。</p><p>Go是如何面对并这个问题的呢？接下来G V1.5版本 就用<strong>三色并发标记法</strong>来优化这个问题.</p><h2 id=go-v15的三色并发标记法>Go V1.5的三色并发标记法</h2><p>三色标记法 实际上就是通过三个阶段的标记来确定清楚的对象都有哪些. 我们来看一下具体的过程.</p><p><strong>第一步</strong> , 就是只要是新创建的对象,默认的颜色都是标记为“白色”.</p><p><img src=/images/f97b6289-f495-4afd-a3b7-f89c6f106d82.png alt></p><p>这里面需要注意的是, 所谓“程序”, 则是一些对象的跟节点集合.</p><p><img src=/images/16192886-775b-461a-b9d0-d74a2f3f76d0.png alt></p><p>所以上图,可以转换如下的方式来表示.</p><p><strong>第二步</strong>, 每次GC回收开始, 然后从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合。</p><p><img src=/images/89041a5e-2ff0-484f-acb5-486aa84cc0f1.png alt></p><p><strong>第三步</strong>, 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合</p><p><img src=/images/3451b546-570c-4995-9eab-2eb50f5b25cf.png alt></p><p><strong>第四步</strong>, 重复<strong>第三步</strong>, 直到灰色中无任何对象.</p><p><img src=/images/8cdbacc0-3b34-46c8-9f49-89f9bda89902.png alt></p><p><img src=/images/fcee2e45-8d1f-4421-a38a-6310ea5f7620.png alt></p><p><strong>第五步</strong>: 回收所有的白色标记表的对象. 也就是回收垃圾.</p><p><img src=/images/1a47f5e7-acc4-4dbe-810e-379695bdc531.png alt></p><p>以上便是<code>三色并发标记法</code>, 不难看出,我们上面已经清楚的体现<code>三色</code>的特性, 那么又是如何实现并行的呢?</p><blockquote><p>Go是如何解决标记-清除(mark and sweep)算法中的卡顿(stw，stop the world)问题的呢？</p></blockquote><h2 id=没有stw的三色标记法>没有STW的三色标记法</h2><p>​ 我们还是基于上述的三色并发标记法来说, 他是一定要依赖STW的. 因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性。我们举一个场景.</p><p>如果三色标记法, 标记过程不使用STW将会发生什么事情?</p><hr><p><img src=/images/21516ce2-d194-4394-9b62-9c36563d4b2b.png alt></p><p><img src=/images/d6592a51-f284-4fbc-905c-50dc59d92103.png alt></p><p><img src=/images/b107beef-233d-4968-8b55-ab2dd42cad4f.png alt></p><p><img src=/images/a10a9998-e626-4b6c-8aa9-4030238f28b1.png alt></p><p><img src=/images/787819ca-f386-4c30-bc51-819ad368dfdb.png alt></p><p>可以看出，有两个问题, 在三色标记法中,是不希望被发生的</p><ul><li>条件1: 一个白色对象被黑色对象引用**(白色被挂在黑色下)**</li><li>条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏**(灰色同时丢了该白色)**</li></ul><p>当以上两个条件同时满足时, 就会出现对象丢失现象!</p><p>当然, 如果上述中的白色对象3, 如果他还有很多下游对象的话, 也会一并都清理掉.</p><p>​ 为了防止这种现象的发生，最简单的方式就是STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是<strong>STW的过程有明显的资源浪费，对所有的用户程序都有很大影响</strong>，如何能在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少STW时间呢？</p><p>​ 答案就是, 那么我们只要使用一个机制,来破坏上面的两个条件就可以了.</p><h2 id=屏障机制>屏障机制</h2><p>我们让GC回收器,满足下面两种情况之一时,可保对象不丢失. 所以引出两种方式.</p><h3 id=强-弱-三色不变式>“强-弱” 三色不变式</h3><ul><li>强三色不变式</li></ul><p>不存在黑色对象引用到白色对象的指针。</p><p><img src=/images/c7612fff-702e-4ffe-8055-dcc7d93b0fea.png alt></p><ul><li>弱三色不变式</li></ul><p>所有被黑色对象引用的白色对象都处于灰色保护状态.</p><p><img src=/images/466357c5-9a01-40f8-9596-e1b767033d20.png alt></p><p>为了遵循上述的两个方式,Golang团队初步得到了如下具体的两种屏障方式“插入屏障”, “删除屏障”.</p><h3 id=插入屏障>插入屏障</h3><p><code>具体操作</code>: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)</p><p><code>满足</code>: <strong>强三色不变式</strong>. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)</p><p>伪码如下:</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75af00>添加下游对象</span><span style=color:#111>(</span><span style=color:#75af00>当前下游对象slot</span><span style=color:#111>,</span> <span style=color:#75af00>新下游对象ptr</span><span style=color:#111>)</span> <span style=color:#111>{</span>   
</span></span><span style=display:flex><span>  <span style=color:#75715e>//1</span>
</span></span><span style=display:flex><span>  <span style=color:#75af00>标记灰色</span><span style=color:#111>(</span><span style=color:#75af00>新下游对象ptr</span><span style=color:#111>)</span>   
</span></span><span style=display:flex><span>  <span style=color:#75715e>//2</span>
</span></span><span style=display:flex><span>  <span style=color:#75af00>当前下游对象slot</span> <span style=color:#111>=</span> <span style=color:#75af00>新下游对象ptr</span>                   
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span></code></pre></div><p>场景：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75af00>A</span><span style=color:#111>.</span><span style=color:#75af00>添加下游对象</span><span style=color:#111>(</span><span style=color:#00a8c8>nil</span><span style=color:#111>,</span> <span style=color:#75af00>B</span><span style=color:#111>)</span>   <span style=color:#75715e>//A 之前没有下游， 新添加一个下游对象B， B被标记为灰色</span>
</span></span><span style=display:flex><span><span style=color:#75af00>A</span><span style=color:#111>.</span><span style=color:#75af00>添加下游对象</span><span style=color:#111>(</span><span style=color:#75af00>C</span><span style=color:#111>,</span> <span style=color:#75af00>B</span><span style=color:#111>)</span>     <span style=color:#75715e>//A 将下游对象C 更换为B，  B被标记为灰色</span>
</span></span></code></pre></div><p>​ 这段伪码逻辑就是写屏障,. 我们知道,黑色对象的内存槽有两种位置, <code>栈</code>和<code>堆</code>. 栈空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用, 所以“插入屏障”机制,在<strong>栈空间的对象操作中不使用</strong>. 而仅仅使用在堆空间对象的操作中.</p><p>​ 接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><hr><p><img src=/images/82e4e137-4b21-4a48-a2c2-0ca38eec9d7d.png alt></p><p><img src=/images/63488ff2-4d52-4a77-b55b-2052b9c66b30.png alt></p><hr><p><img src=/images/f1392990-751d-4b0f-9eeb-69697d821aad.png alt></p><hr><p><img src=/images/2e4c728d-3d54-403c-b8e2-e2e19bb97ae2.png alt></p><p><img src=/images/7b3ec6ef-1694-4ba4-b120-6066451f6e44.png alt></p><p><img src=/images/a5bf6b22-b34b-4c7e-81c3-7e422d560825.png alt></p><hr><p>但是如果栈不添加,当全部三色标记扫描之后,栈上有可能依然存在白色对象被引用的情况(如上图的对象9). 所以要对栈重新进行三色标记扫描, 但这次为了对象不丢失, 要对本次标记扫描启动STW暂停. 直到栈空间的三色标记结束.</p><hr><p><img src=/images/0805cff3-e89e-4eed-a40c-31d8af5d8ad4.png alt></p><hr><p><img src=/images/c5f528e4-d7ae-4249-9370-78e514144b0a.png alt></p><p><img src=/images/b19b22ef-8484-4708-979a-2d1cbdefc23b.png alt></p><hr><p>最后将栈和堆空间 扫描剩余的全部 白色节点清除. 这次STW大约的时间在10~100ms间.</p><hr><p><img src=/images/446787fa-1ad8-451b-a8f3-e87ca8f46b82.png alt></p><hr><h3 id=删除屏障>删除屏障</h3><p><code>具体操作</code>: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。</p><p><code>满足</code>: <strong>弱三色不变式</strong>. (保护灰色对象到白色对象的路径不会断)</p><p>伪代码：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75af00>添加下游对象</span><span style=color:#111>(</span><span style=color:#75af00>当前下游对象slot</span><span style=color:#960050;background-color:#1e0010>，</span> <span style=color:#75af00>新下游对象ptr</span><span style=color:#111>)</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//1</span>
</span></span><span style=display:flex><span>  <span style=color:#00a8c8>if</span> <span style=color:#111>(</span><span style=color:#75af00>当前下游对象slot是灰色</span> <span style=color:#f92672>||</span> <span style=color:#75af00>当前下游对象slot是白色</span><span style=color:#111>)</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>        <span style=color:#75af00>标记灰色</span><span style=color:#111>(</span><span style=color:#75af00>当前下游对象slot</span><span style=color:#111>)</span>     <span style=color:#75715e>//slot为被删除对象， 标记为灰色</span>
</span></span><span style=display:flex><span>  <span style=color:#111>}</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//2</span>
</span></span><span style=display:flex><span>  <span style=color:#75af00>当前下游对象slot</span> <span style=color:#111>=</span> <span style=color:#75af00>新下游对象ptr</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span></code></pre></div><p>场景：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75af00>A</span><span style=color:#111>.</span><span style=color:#75af00>添加下游对象</span><span style=color:#111>(</span><span style=color:#75af00>B</span><span style=color:#111>,</span> <span style=color:#00a8c8>nil</span><span style=color:#111>)</span>   <span style=color:#75715e>//A对象，删除B对象的引用。  B被A删除，被标记为灰(如果B之前为白)</span>
</span></span><span style=display:flex><span><span style=color:#75af00>A</span><span style=color:#111>.</span><span style=color:#75af00>添加下游对象</span><span style=color:#111>(</span><span style=color:#75af00>B</span><span style=color:#111>,</span> <span style=color:#75af00>C</span><span style=color:#111>)</span>       <span style=color:#75715e>//A对象，更换下游B变成C。   B被A删除，被标记为灰(如果B之前为白)</span>
</span></span></code></pre></div><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><hr><p><img src=/images/37cec983-9229-45e1-b5b1-cc17cefaebd3.png alt></p><hr><p><img src=/images/f3affdd8-36d5-4c28-9efb-932e8eafe855.png alt></p><hr><p><img src=/images/231684ca-812d-4ce5-af4f-772503d1be63.png alt></p><p><img src=/images/ed0497f6-15b1-4375-bf60-2df7a1af08b8.png alt></p><p><img src=/images/b51da9dd-7b88-403e-a4e7-1e1c3614e897.png alt></p><p><img src=/images/430453b0-b9f1-420a-bfb4-5c6e8cc6deda.png alt></p><p><img src=/images/e1546bc1-a282-4746-94c6-fc468329e7d3.png alt></p><hr><p>这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。</p><h2 id=go-v18的混合写屏障hybrid-write-barrier机制>Go V1.8的混合写屏障(hybrid write barrier)机制</h2><p>插入写屏障和删除写屏障的短板：</p><ul><li>插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；</li><li>删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。</li></ul><p>Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。</p><hr><h3 id=混合写屏障规则>混合写屏障规则</h3><p><code>具体操作</code>:</p><p>1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，</p><p>2、GC期间，任何在栈上创建的新对象，均为黑色。</p><p>3、被删除的对象标记为灰色。</p><p>4、被添加的对象标记为灰色。</p><p><code>满足</code>: 变形的<strong>弱三色不变式</strong>.</p><p>伪代码：</p><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75af00>添加下游对象</span><span style=color:#111>(</span><span style=color:#75af00>当前下游对象slot</span><span style=color:#111>,</span> <span style=color:#75af00>新下游对象ptr</span><span style=color:#111>)</span> <span style=color:#111>{</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//1 </span>
</span></span><span style=display:flex><span>        <span style=color:#75af00>标记灰色</span><span style=color:#111>(</span><span style=color:#75af00>当前下游对象slot</span><span style=color:#111>)</span>    <span style=color:#75715e>//只要当前下游对象被移走，就标记灰色</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//2 </span>
</span></span><span style=display:flex><span>    <span style=color:#75af00>标记灰色</span><span style=color:#111>(</span><span style=color:#75af00>新下游对象ptr</span><span style=color:#111>)</span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>//3</span>
</span></span><span style=display:flex><span>    <span style=color:#75af00>当前下游对象slot</span> <span style=color:#111>=</span> <span style=color:#75af00>新下游对象ptr</span>
</span></span><span style=display:flex><span><span style=color:#111>}</span>
</span></span></code></pre></div><blockquote><p>这里我们注意， 屏障技术是不在栈上应用的，因为要保证栈的运行效率。</p></blockquote><h3 id=混合写屏障的具体场景分析>混合写屏障的具体场景分析</h3><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><blockquote><p>注意混合写屏障是Gc的一种屏障机制，所以只是当程序执行GC的时候，才会触发这种机制。</p></blockquote><h4 id=gc开始扫描栈区将可达对象全部标记为黑>GC开始：扫描栈区，将可达对象全部标记为黑</h4><p><img src=/images/cd30cf15-058a-4a64-a2f8-775c87dfea89.png alt></p><p><img src=/images/a9c3a537-6c7b-4d07-8fc7-6f1c4c181cfb.png alt></p><hr><h4 id=场景一-对象被一个堆对象删除引用成为栈对象的下游>场景一： 对象被一个堆对象删除引用，成为栈对象的下游</h4><blockquote><p>伪代码</p></blockquote><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>//前提：堆对象4-&gt;对象7 = 对象7；  //对象7 被 对象4引用</span>
</span></span><span style=display:flex><span><span style=color:#75af00>栈对象1</span><span style=color:#f92672>-</span><span style=color:#111>&gt;</span><span style=color:#75af00>对象7</span> <span style=color:#111>=</span> <span style=color:#75af00>堆对象7</span><span style=color:#960050;background-color:#1e0010>；</span>  <span style=color:#75715e>//将堆对象7 挂在 栈对象1 下游</span>
</span></span><span style=display:flex><span><span style=color:#75af00>堆对象4</span><span style=color:#f92672>-</span><span style=color:#111>&gt;</span><span style=color:#75af00>对象7</span> <span style=color:#111>=</span> <span style=color:#75af00>null</span><span style=color:#960050;background-color:#1e0010>；</span>    <span style=color:#75715e>//对象4 删除引用 对象7</span>
</span></span></code></pre></div><p><img src=/images/ebaedc9a-8cd0-4598-8962-2f2e7fb3ac36.png alt></p><hr><p><img src=/images/a3066126-ad87-44a0-b712-4e80b69ad25d.png alt></p><h4 id=场景二-对象被一个栈对象删除引用成为另一个栈对象的下游>场景二： 对象被一个栈对象删除引用，成为另一个栈对象的下游</h4><blockquote><p>伪代码</p></blockquote><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75af00>new</span> <span style=color:#75af00>栈对象9</span><span style=color:#960050;background-color:#1e0010>；</span>
</span></span><span style=display:flex><span><span style=color:#75af00>对象8</span><span style=color:#f92672>-</span><span style=color:#111>&gt;</span><span style=color:#75af00>对象3</span> <span style=color:#111>=</span> <span style=color:#75af00>对象3</span><span style=color:#960050;background-color:#1e0010>；</span>      <span style=color:#75715e>//将栈对象3 挂在 栈对象9 下游</span>
</span></span><span style=display:flex><span><span style=color:#75af00>对象2</span><span style=color:#f92672>-</span><span style=color:#111>&gt;</span><span style=color:#75af00>对象3</span> <span style=color:#111>=</span> <span style=color:#75af00>null</span><span style=color:#960050;background-color:#1e0010>；</span>      <span style=color:#75715e>//对象2 删除引用 对象3</span>
</span></span></code></pre></div><hr><p><img src=/images/4899f7b2-d951-4d9c-9880-6fb79fa01fee.png alt></p><p><img src=/images/a185fd86-0ca0-4294-9ebf-6c8a73f8af19.png alt></p><p><img src=/images/eb499138-8d6a-4c75-a4a9-1dad614879bf.png alt></p><hr><h4 id=场景三对象被一个堆对象删除引用成为另一个堆对象的下游>场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游</h4><blockquote><p>伪代码</p></blockquote><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75af00>堆对象10</span><span style=color:#f92672>-</span><span style=color:#111>&gt;</span><span style=color:#75af00>对象7</span> <span style=color:#111>=</span> <span style=color:#75af00>堆对象7</span><span style=color:#960050;background-color:#1e0010>；</span>       <span style=color:#75715e>//将堆对象7 挂在 堆对象10 下游</span>
</span></span><span style=display:flex><span><span style=color:#75af00>堆对象4</span><span style=color:#f92672>-</span><span style=color:#111>&gt;</span><span style=color:#75af00>对象7</span> <span style=color:#111>=</span> <span style=color:#75af00>null</span><span style=color:#960050;background-color:#1e0010>；</span>         <span style=color:#75715e>//对象4 删除引用 对象7</span>
</span></span></code></pre></div><hr><p><img src=/images/cb9a84fe-73ec-43e7-9d37-f14683e4f6e4.png alt></p><hr><p><img src=/images/e010d5a5-4867-43df-8e82-1a4368f2c8e2.png alt></p><p><img src=/images/d11efffb-50de-4aed-b6a6-06eb20a4824e.png alt></p><hr><h4 id=场景四对象从一个栈对象删除引用成为另一个堆对象的下游>场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游</h4><blockquote><p>伪代码</p></blockquote><div class=highlight><pre tabindex=0 style=color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75af00>堆对象10</span><span style=color:#f92672>-</span><span style=color:#111>&gt;</span><span style=color:#75af00>对象7</span> <span style=color:#111>=</span> <span style=color:#75af00>堆对象7</span><span style=color:#960050;background-color:#1e0010>；</span>       <span style=color:#75715e>//将堆对象7 挂在 堆对象10 下游</span>
</span></span><span style=display:flex><span><span style=color:#75af00>堆对象4</span><span style=color:#f92672>-</span><span style=color:#111>&gt;</span><span style=color:#75af00>对象7</span> <span style=color:#111>=</span> <span style=color:#75af00>null</span><span style=color:#960050;background-color:#1e0010>；</span>         <span style=color:#75715e>//对象4 删除引用 对象7</span>
</span></span></code></pre></div><hr><p><img src=/images/29e311a4-4387-4387-be10-06bf33338c01.png alt></p><p><img src=/images/ba80f06b-42a9-463d-b88f-62ee6f83bc4d.png alt></p><p><img src=/images/497960cd-b419-430a-90e5-88f2e37bc848.png alt></p><hr><p>​ Golang中的混合写屏障满足<code>弱三色不变式</code>，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。</p><h2 id=总结>总结</h2><p>​ 以上便是Golang的GC全部的标记-清除逻辑及场景演示全过程。</p><p>GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。</p><p>GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通</p><p>GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。</p><h2 id=文章转自>文章转自</h2><p><a href=https://www.jianshu.com/p/4c5a303af470>https://www.jianshu.com/p/4c5a303af470</a></p></div><footer class=post-footer><div class=post-license><p><strong>Article Title:</strong> golang GC 垃圾回收机制</p><p><strong>Author:</strong> daemon365</p><p><strong>Permalink:</strong> <a href=https://daemon365.dev/post/go/golang_gc_garbage_collection_mechanism/>https://daemon365.dev/post/go/golang_gc_garbage_collection_mechanism/</a></p><p><strong>License:</strong> This article is licensed under
<a href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank rel=noopener>BY-NC-SA</a>. Please cite the source when reposting.</p></div><nav class=post-navigation><a href=/post/go/viper_configuration_management/ class=nav-prev><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="19" y1="12" x2="5" y2="12"/><polyline points="12 19 5 12 12 5"/></svg><div><span class=nav-label>Previous</span>
<span class=nav-title>viper配置管理</span></div></a><a href=/post/go/golang_channel_principle/ class=nav-next><div><span class=nav-label>Next</span>
<span class=nav-title>golang channel原理</span></div><svg class="icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="5" y1="12" x2="19" y2="12"/><polyline points="12 5 19 12 12 19"/></svg></a></nav><div class=post-comments><script src=https://utteranc.es/client.js repo=daemon365/blog issue-term=pathname label=comments theme=preferred-color-scheme crossorigin=anonymous async></script></div></footer></article></div></div><div class=toc-float-button id=tocButton><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 19.5A2.5 2.5.0 016.5 17H20"/><path d="M6.5 2H20v20H6.5A2.5 2.5.0 014 19.5v-15A2.5 2.5.0 016.5 2z"/></svg></div><div class=toc-panel id=tocPanel><div class=toc-panel-header><h3 class=toc-panel-title>Table of Contents</h3><button class=toc-panel-close id=tocClose>
<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button></div><nav class=toc-panel-nav id=TableOfContents><nav id=TableOfContents><ul><li><a href=#go-v13之前的标记-清除mark-and-sweep算法>Go V1.3之前的标记-清除(mark and sweep)算法</a></li><li><a href=#标记-清扫mark-and-sweep的缺点>标记-清扫(mark and sweep)的缺点</a></li><li><a href=#go-v15的三色并发标记法>Go V1.5的三色并发标记法</a></li><li><a href=#没有stw的三色标记法>没有STW的三色标记法</a></li><li><a href=#屏障机制>屏障机制</a><ul><li><a href=#强-弱-三色不变式>“强-弱” 三色不变式</a></li><li><a href=#插入屏障>插入屏障</a></li><li><a href=#删除屏障>删除屏障</a></li></ul></li><li><a href=#go-v18的混合写屏障hybrid-write-barrier机制>Go V1.8的混合写屏障(hybrid write barrier)机制</a><ul><li><a href=#混合写屏障规则>混合写屏障规则</a></li><li><a href=#混合写屏障的具体场景分析>混合写屏障的具体场景分析</a><ul><li><a href=#gc开始扫描栈区将可达对象全部标记为黑>GC开始：扫描栈区，将可达对象全部标记为黑</a></li><li><a href=#场景一-对象被一个堆对象删除引用成为栈对象的下游>场景一： 对象被一个堆对象删除引用，成为栈对象的下游</a></li><li><a href=#场景二-对象被一个栈对象删除引用成为另一个栈对象的下游>场景二： 对象被一个栈对象删除引用，成为另一个栈对象的下游</a></li><li><a href=#场景三对象被一个堆对象删除引用成为另一个堆对象的下游>场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游</a></li><li><a href=#场景四对象从一个栈对象删除引用成为另一个堆对象的下游>场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游</a></li></ul></li></ul></li><li><a href=#总结>总结</a></li><li><a href=#文章转自>文章转自</a></li></ul></nav></nav></div></main><footer class=site-footer><div class=container><div class=footer-content><div class=footer-info><p class=copyright>© 2026 daemon365</p><p class=powered-by>由 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 和 <a href=https://github.com/daemon365/hugo-theme-daemon target=_blank rel=noopener>Daemon</a> 驱动</p></div><div class=social-links><a href=https://github.com/daemon365 target=_blank rel=noopener aria-label=GitHub><svg class="icon" width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0C5.374.0.0 5.373.0 12c0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931.0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176.0.0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221.0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576C20.566 21.797 24 17.3 24 12c0-6.627-5.373-12-12-12z"/></svg>
</a><a href=mailto:daemon365@foxmail.com aria-label=Email><svg class="icon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 4h16c1.1.0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1.0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/></svg></a></div></div></div></footer><div class=search-modal id=searchModal><div class=search-modal-backdrop></div><div class=search-modal-content><div class=search-modal-header><input type=text class=search-input id=searchInput placeholder=搜索文章... autofocus>
<button class=search-close aria-label="Close search">
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg></button></div><div class=search-results id=searchResults><p class=search-hint>输入 2 个或更多字符开始搜索</p></div></div></div><script src=/js/components/search.js></script><script src=/js/components/toc.js></script><script src=/js/components/scroll-effects.js></script><script src=/js/components/code-copy.js></script><script src=/js/components/lazy-loading.js></script><script src=/js/components/image-preview.js></script><script src=/js/components/back-to-top.js></script><script src=/js/main-new.js></script><script>"serviceWorker"in navigator&&window.addEventListener("load",()=>{navigator.serviceWorker.register("/sw.js").then(e=>{console.log("Service Worker registered:",e.scope)}).catch(e=>{console.log("Service Worker registration failed:",e)})})</script></body></html>