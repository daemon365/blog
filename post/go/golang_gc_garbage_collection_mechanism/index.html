<!doctype html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.138.0"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/favicon.ico><meta itemprop=name content="golang GC 垃圾回收机制"><meta itemprop=description content="Don't let yourself stop."><meta name=description content="Don't let yourself stop."><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://daemon365.dev/imgs/daemon365.png"><meta itemprop=keywords content="go"><meta property="og:type" content="article"><meta property="og:title" content="golang GC 垃圾回收机制"><meta property="og:description" content="Don't let yourself stop."><meta property="og:image" content="/imgs/daemon365.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://daemon365.dev/post/go/golang_gc_garbage_collection_mechanism/"><meta property="og:site_name" content="Daemon"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="daemon365"><meta property="article:published_time" content="2021-02-20 00:00:00 +0800 +0800"><meta property="article:modified_time" content="2021-02-20 00:00:00 +0800 +0800"><link type=text/css rel=stylesheet href=https://daemon365.dev/3rd/font-awesome/6.6.0/css/all.min.css><link type=text/css rel=stylesheet href=https://daemon365.dev/3rd/animate.css/4.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://daemon365.dev/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href=/css/main.min.3617ff82394b233ac557ab6bc7e098de56307034954005671d085539d7bd0873.css><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":true,"isHome":false,"isPage":true,"path":"golang_gc_garbage_collection_mechanism","permalink":"https://daemon365.dev/post/go/golang_gc_garbage_collection_mechanism/","title":"golang GC 垃圾回收机制","waline":{"js":[{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"2.15.8"},{"alias":"@waline/client","alias_name":"waline","file":"dist/comment.js","name":"comment","version":"2.15.8"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.id="LA_COLLECT",e.src="https://sdk.51.la/js-sdk-pro.min.js",e.async="true",e.onload=function(){LA.init({id:"JmAHxEAUVgyS8B1c",ck:"JmAHxEAUVgyS8B1c",autoTrack:!0})},document.head.appendChild(e)})</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>golang GC 垃圾回收机制 - Daemon</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Daemon</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>Don't let yourself stop.</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>Home</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>About</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>Archives
<span class=badge>93</span></a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>Commonweal</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#go-v13之前的标记-清除mark-and-sweep算法>Go V1.3之前的标记-清除(mark and sweep)算法</a></li><li><a href=#标记-清扫mark-and-sweep的缺点>标记-清扫(mark and sweep)的缺点</a></li><li><a href=#go-v15的三色并发标记法>Go V1.5的三色并发标记法</a></li><li><a href=#没有stw的三色标记法>没有STW的三色标记法</a></li><li><a href=#屏障机制>屏障机制</a><ul><li><a href=#强-弱-三色不变式>“强-弱” 三色不变式</a></li><li><a href=#插入屏障>插入屏障</a></li><li><a href=#删除屏障>删除屏障</a></li></ul></li><li><a href=#go-v18的混合写屏障hybrid-write-barrier机制>Go V1.8的混合写屏障(hybrid write barrier)机制</a><ul><li><a href=#混合写屏障规则>混合写屏障规则</a></li><li><a href=#混合写屏障的具体场景分析>混合写屏障的具体场景分析</a><ul><li><a href=#gc开始扫描栈区将可达对象全部标记为黑>GC开始：扫描栈区，将可达对象全部标记为黑</a></li><li><a href=#场景一-对象被一个堆对象删除引用成为栈对象的下游>场景一： 对象被一个堆对象删除引用，成为栈对象的下游</a></li><li><a href=#场景二-对象被一个栈对象删除引用成为另一个栈对象的下游>场景二： 对象被一个栈对象删除引用，成为另一个栈对象的下游</a></li><li><a href=#场景三对象被一个堆对象删除引用成为另一个堆对象的下游>场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游</a></li><li><a href=#场景四对象从一个栈对象删除引用成为另一个堆对象的下游>场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游</a></li></ul></li></ul></li><li><a href=#总结>总结</a></li><li><a href=#文章转自>文章转自</a></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=daemon365 src=/imgs/img-lazy-loading.gif data-src=/imgs/daemon365.png><p class=site-author-name itemprop=name>daemon365</p><div class=site-description itemprop=description>Don't let yourself stop.</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>93</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>7</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>52</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/daemon365 title="Github → https://github.com/daemon365" rel=noopener target=_blank><i class="fab fa-github fa-fw"></i>
Github</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://go-kratos.dev title=https://go-kratos.dev target=_blank>kratos</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script><script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://daemon365.dev/post/go/golang_gc_garbage_collection_mechanism/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/daemon365.png"><meta itemprop=name content="daemon365"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="daemon365"><meta itemprop=description content="Don't let yourself stop."></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="golang GC 垃圾回收机制"><meta itemprop=description content="垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的对象，让出存储器资源，无需程序员手动执行。"></span><header class=post-header><h1 class=post-title itemprop="name headline">golang GC 垃圾回收机制</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2021-02-20 00:00:00 +0800 +0800" itemprop="dateCreated datePublished" datetime="2021-02-20 00:00:00 +0800 +0800">2021-02-20
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/go itemprop=url rel=index><span itemprop=name>go</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="fas fa-solid fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>3887</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="fas fa-solid fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>8分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=busuanzi_value_page_pv data-path=/post/go/golang_gc_garbage_collection_mechanism/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的自动的内存管理机制，自动释放不需要的对象，让出存储器资源，无需程序员手动执行。</p><p>Golang中的垃圾回收主要应用三色标记法，GC过程和其他用户goroutine可并发运行，但需要一定时间的<strong>STW(stop the world)</strong>，STW的过程中，CPU不执行用户代码，全部用于垃圾回收，这个过程的影响很大，Golang进行了多次的迭代优化来解决这个问题。</p><h2 id=go-v13之前的标记-清除mark-and-sweep算法>Go V1.3之前的标记-清除(mark and sweep)算法
<a class=header-anchor href=#go-v13%e4%b9%8b%e5%89%8d%e7%9a%84%e6%a0%87%e8%ae%b0-%e6%b8%85%e9%99%a4mark-and-sweep%e7%ae%97%e6%b3%95></a></h2><p>此算法主要有两个主要的步骤：</p><ul><li>标记(Mark phase)</li><li>清除(Sweep phase)</li></ul><p><strong>第一步</strong>，暂停程序业务逻辑, 找出不可达的对象，然后做上标记。第二步，回收标记好的对象。</p><p>操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停！即 <code>STW(stop the world)</code>。也就是说，这段时间程序会卡在哪儿。</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/e7452cc0-956d-44ea-8ef6-22bad882f1d8.png alt></p><p><strong>第二步</strong>, 开始标记，程序找出它所有可达的对象，并做上标记。如下图所示：</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/a2d30455-7d6a-4039-8091-c369e405ce2b.png alt></p><p><strong>第三步</strong>, 标记完了之后，然后开始清除未标记的对象. 结果如下.</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/532f5acd-aac6-4a12-858c-4f79c7eeba24.png alt></p><p><strong>第四步</strong>, 停止暂停，让程序继续跑。然后循环重复这个过程，直到process程序生命周期结束。</p><h2 id=标记-清扫mark-and-sweep的缺点>标记-清扫(mark and sweep)的缺点
<a class=header-anchor href=#%e6%a0%87%e8%ae%b0-%e6%b8%85%e6%89%abmark-and-sweep%e7%9a%84%e7%bc%ba%e7%82%b9></a></h2><ul><li>STW，stop the world；让程序暂停，程序出现卡顿 <strong>(重要问题)</strong>。</li><li>标记需要扫描整个heap</li><li>清除数据会产生heap碎片</li></ul><p>所以Go V1.3版本之前就是以上来实施的, 流程是</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/c24c6980-7fb9-4c34-8576-064bef2b2ba1.png alt></p><p>Go V1.3 做了简单的优化,将STW提前, 减少STW暂停的时间范围.如下所示</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/3cfb6c99-91b8-4693-9446-203000b2e3de.png alt></p><p><strong>这里面最重要的问题就是：mark-and-sweep 算法会暂停整个程序</strong> 。</p><p>Go是如何面对并这个问题的呢？接下来G V1.5版本 就用<strong>三色并发标记法</strong>来优化这个问题.</p><h2 id=go-v15的三色并发标记法>Go V1.5的三色并发标记法
<a class=header-anchor href=#go-v15%e7%9a%84%e4%b8%89%e8%89%b2%e5%b9%b6%e5%8f%91%e6%a0%87%e8%ae%b0%e6%b3%95></a></h2><p>三色标记法 实际上就是通过三个阶段的标记来确定清楚的对象都有哪些. 我们来看一下具体的过程.</p><p><strong>第一步</strong> , 就是只要是新创建的对象,默认的颜色都是标记为“白色”.</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/f97b6289-f495-4afd-a3b7-f89c6f106d82.png alt></p><p>这里面需要注意的是, 所谓“程序”, 则是一些对象的跟节点集合.</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/16192886-775b-461a-b9d0-d74a2f3f76d0.png alt></p><p>所以上图,可以转换如下的方式来表示.</p><p><strong>第二步</strong>, 每次GC回收开始, 然后从根节点开始遍历所有对象，把遍历到的对象从白色集合放入“灰色”集合。</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/89041a5e-2ff0-484f-acb5-486aa84cc0f1.png alt></p><p><strong>第三步</strong>, 遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/3451b546-570c-4995-9eab-2eb50f5b25cf.png alt></p><p><strong>第四步</strong>, 重复<strong>第三步</strong>, 直到灰色中无任何对象.</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/8cdbacc0-3b34-46c8-9f49-89f9bda89902.png alt></p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/fcee2e45-8d1f-4421-a38a-6310ea5f7620.png alt></p><p><strong>第五步</strong>: 回收所有的白色标记表的对象. 也就是回收垃圾.</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/1a47f5e7-acc4-4dbe-810e-379695bdc531.png alt></p><p>以上便是<code>三色并发标记法</code>, 不难看出,我们上面已经清楚的体现<code>三色</code>的特性, 那么又是如何实现并行的呢?</p><blockquote><p>Go是如何解决标记-清除(mark and sweep)算法中的卡顿(stw，stop the world)问题的呢？</p></blockquote><h2 id=没有stw的三色标记法>没有STW的三色标记法
<a class=header-anchor href=#%e6%b2%a1%e6%9c%89stw%e7%9a%84%e4%b8%89%e8%89%b2%e6%a0%87%e8%ae%b0%e6%b3%95></a></h2><p>​ 我们还是基于上述的三色并发标记法来说, 他是一定要依赖STW的. 因为如果不暂停程序, 程序的逻辑改变对象引用关系, 这种动作如果在标记阶段做了修改，会影响标记结果的正确性。我们举一个场景.</p><p>如果三色标记法, 标记过程不使用STW将会发生什么事情?</p><hr><p><img src=/imgs/img-lazy-loading.gif data-src=/images/21516ce2-d194-4394-9b62-9c36563d4b2b.png alt></p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/d6592a51-f284-4fbc-905c-50dc59d92103.png alt></p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/b107beef-233d-4968-8b55-ab2dd42cad4f.png alt></p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/a10a9998-e626-4b6c-8aa9-4030238f28b1.png alt></p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/787819ca-f386-4c30-bc51-819ad368dfdb.png alt></p><p>可以看出，有两个问题, 在三色标记法中,是不希望被发生的</p><ul><li>条件1: 一个白色对象被黑色对象引用**(白色被挂在黑色下)**</li><li>条件2: 灰色对象与它之间的可达关系的白色对象遭到破坏**(灰色同时丢了该白色)**</li></ul><p>当以上两个条件同时满足时, 就会出现对象丢失现象!</p><p>当然, 如果上述中的白色对象3, 如果他还有很多下游对象的话, 也会一并都清理掉.</p><p>​ 为了防止这种现象的发生，最简单的方式就是STW，直接禁止掉其他用户程序对对象引用关系的干扰，但是<strong>STW的过程有明显的资源浪费，对所有的用户程序都有很大影响</strong>，如何能在保证对象不丢失的情况下合理的尽可能的提高GC效率，减少STW时间呢？</p><p>​ 答案就是, 那么我们只要使用一个机制,来破坏上面的两个条件就可以了.</p><h2 id=屏障机制>屏障机制
<a class=header-anchor href=#%e5%b1%8f%e9%9a%9c%e6%9c%ba%e5%88%b6></a></h2><p>我们让GC回收器,满足下面两种情况之一时,可保对象不丢失. 所以引出两种方式.</p><h3 id=强-弱-三色不变式>“强-弱” 三色不变式
<a class=header-anchor href=#%e5%bc%ba-%e5%bc%b1-%e4%b8%89%e8%89%b2%e4%b8%8d%e5%8f%98%e5%bc%8f></a></h3><ul><li>强三色不变式</li></ul><p>不存在黑色对象引用到白色对象的指针。</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/c7612fff-702e-4ffe-8055-dcc7d93b0fea.png alt></p><ul><li>弱三色不变式</li></ul><p>所有被黑色对象引用的白色对象都处于灰色保护状态.</p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/466357c5-9a01-40f8-9596-e1b767033d20.png alt></p><p>为了遵循上述的两个方式,Golang团队初步得到了如下具体的两种屏障方式“插入屏障”, “删除屏障”.</p><h3 id=插入屏障>插入屏障
<a class=header-anchor href=#%e6%8f%92%e5%85%a5%e5%b1%8f%e9%9a%9c></a></h3><p><code>具体操作</code>: 在A对象引用B对象的时候，B对象被标记为灰色。(将B挂在A下游，B必须被标记为灰色)</p><p><code>满足</code>: <strong>强三色不变式</strong>. (不存在黑色对象引用白色对象的情况了， 因为白色会强制变成灰色)</p><p>伪码如下:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>添加下游对象</span>(<span style=color:#a6e22e>当前下游对象slot</span>, <span style=color:#a6e22e>新下游对象ptr</span>) {   
</span></span><span style=display:flex><span>  <span style=color:#75715e>//1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>标记灰色</span>(<span style=color:#a6e22e>新下游对象ptr</span>)   
</span></span><span style=display:flex><span>  <span style=color:#75715e>//2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>当前下游对象slot</span> = <span style=color:#a6e22e>新下游对象ptr</span>                   
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>场景：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>A</span>.<span style=color:#a6e22e>添加下游对象</span>(<span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>B</span>)   <span style=color:#75715e>//A 之前没有下游， 新添加一个下游对象B， B被标记为灰色
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>A</span>.<span style=color:#a6e22e>添加下游对象</span>(<span style=color:#a6e22e>C</span>, <span style=color:#a6e22e>B</span>)     <span style=color:#75715e>//A 将下游对象C 更换为B，  B被标记为灰色
</span></span></span></code></pre></div><p>​ 这段伪码逻辑就是写屏障,. 我们知道,黑色对象的内存槽有两种位置, <code>栈</code>和<code>堆</code>. 栈空间的特点是容量小,但是要求相应速度快,因为函数调用弹出频繁使用, 所以“插入屏障”机制,在<strong>栈空间的对象操作中不使用</strong>. 而仅仅使用在堆空间对象的操作中.</p><p>​ 接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><hr><p><img src=/imgs/img-lazy-loading.gif data-src=/images/82e4e137-4b21-4a48-a2c2-0ca38eec9d7d.png alt></p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/63488ff2-4d52-4a77-b55b-2052b9c66b30.png alt></p><hr><p><img src=/imgs/img-lazy-loading.gif data-src=/images/f1392990-751d-4b0f-9eeb-69697d821aad.png alt></p><hr><p><img src=/imgs/img-lazy-loading.gif data-src=/images/2e4c728d-3d54-403c-b8e2-e2e19bb97ae2.png alt></p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/7b3ec6ef-1694-4ba4-b120-6066451f6e44.png alt></p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/a5bf6b22-b34b-4c7e-81c3-7e422d560825.png alt></p><hr><p>但是如果栈不添加,当全部三色标记扫描之后,栈上有可能依然存在白色对象被引用的情况(如上图的对象9). 所以要对栈重新进行三色标记扫描, 但这次为了对象不丢失, 要对本次标记扫描启动STW暂停. 直到栈空间的三色标记结束.</p><hr><p><img src=/imgs/img-lazy-loading.gif data-src=/images/0805cff3-e89e-4eed-a40c-31d8af5d8ad4.png alt></p><hr><p><img src=/imgs/img-lazy-loading.gif data-src=/images/c5f528e4-d7ae-4249-9370-78e514144b0a.png alt></p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/b19b22ef-8484-4708-979a-2d1cbdefc23b.png alt></p><hr><p>最后将栈和堆空间 扫描剩余的全部 白色节点清除. 这次STW大约的时间在10~100ms间.</p><hr><p><img src=/imgs/img-lazy-loading.gif data-src=/images/446787fa-1ad8-451b-a8f3-e87ca8f46b82.png alt></p><hr><h3 id=删除屏障>删除屏障
<a class=header-anchor href=#%e5%88%a0%e9%99%a4%e5%b1%8f%e9%9a%9c></a></h3><p><code>具体操作</code>: 被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。</p><p><code>满足</code>: <strong>弱三色不变式</strong>. (保护灰色对象到白色对象的路径不会断)</p><p>伪代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>添加下游对象</span>(<span style=color:#a6e22e>当前下游对象slot</span><span style=color:#960050;background-color:#1e0010>，</span> <span style=color:#a6e22e>新下游对象ptr</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>//1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>当前下游对象slot是灰色</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>当前下游对象slot是白色</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>标记灰色</span>(<span style=color:#a6e22e>当前下游对象slot</span>)     <span style=color:#75715e>//slot为被删除对象， 标记为灰色
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>//2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>当前下游对象slot</span> = <span style=color:#a6e22e>新下游对象ptr</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>场景：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>A</span>.<span style=color:#a6e22e>添加下游对象</span>(<span style=color:#a6e22e>B</span>, <span style=color:#66d9ef>nil</span>)   <span style=color:#75715e>//A对象，删除B对象的引用。  B被A删除，被标记为灰(如果B之前为白)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>A</span>.<span style=color:#a6e22e>添加下游对象</span>(<span style=color:#a6e22e>B</span>, <span style=color:#a6e22e>C</span>)       <span style=color:#75715e>//A对象，更换下游B变成C。   B被A删除，被标记为灰(如果B之前为白)
</span></span></span></code></pre></div><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><hr><p><img src=/imgs/img-lazy-loading.gif data-src=/images/37cec983-9229-45e1-b5b1-cc17cefaebd3.png alt></p><hr><p><img src=/imgs/img-lazy-loading.gif data-src=/images/f3affdd8-36d5-4c28-9efb-932e8eafe855.png alt></p><hr><p><img src=/imgs/img-lazy-loading.gif data-src=/images/231684ca-812d-4ce5-af4f-772503d1be63.png alt></p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/ed0497f6-15b1-4375-bf60-2df7a1af08b8.png alt></p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/b51da9dd-7b88-403e-a4e7-1e1c3614e897.png alt></p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/430453b0-b9f1-420a-bfb4-5c6e8cc6deda.png alt></p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/e1546bc1-a282-4746-94c6-fc468329e7d3.png alt></p><hr><p>这种方式的回收精度低，一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中被清理掉。</p><h2 id=go-v18的混合写屏障hybrid-write-barrier机制>Go V1.8的混合写屏障(hybrid write barrier)机制
<a class=header-anchor href=#go-v18%e7%9a%84%e6%b7%b7%e5%90%88%e5%86%99%e5%b1%8f%e9%9a%9chybrid-write-barrier%e6%9c%ba%e5%88%b6></a></h2><p>插入写屏障和删除写屏障的短板：</p><ul><li>插入写屏障：结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；</li><li>删除写屏障：回收精度低，GC开始时STW扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。</li></ul><p>Go V1.8版本引入了混合写屏障机制（hybrid write barrier），避免了对栈re-scan的过程，极大的减少了STW的时间。结合了两者的优点。</p><hr><h3 id=混合写屏障规则>混合写屏障规则
<a class=header-anchor href=#%e6%b7%b7%e5%90%88%e5%86%99%e5%b1%8f%e9%9a%9c%e8%a7%84%e5%88%99></a></h3><p><code>具体操作</code>:</p><p>1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行第二次重复扫描，无需STW)，</p><p>2、GC期间，任何在栈上创建的新对象，均为黑色。</p><p>3、被删除的对象标记为灰色。</p><p>4、被添加的对象标记为灰色。</p><p><code>满足</code>: 变形的<strong>弱三色不变式</strong>.</p><p>伪代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>添加下游对象</span>(<span style=color:#a6e22e>当前下游对象slot</span>, <span style=color:#a6e22e>新下游对象ptr</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//1 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>标记灰色</span>(<span style=color:#a6e22e>当前下游对象slot</span>)    <span style=color:#75715e>//只要当前下游对象被移走，就标记灰色
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//2 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>标记灰色</span>(<span style=color:#a6e22e>新下游对象ptr</span>)    
</span></span><span style=display:flex><span>    <span style=color:#75715e>//3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>当前下游对象slot</span> = <span style=color:#a6e22e>新下游对象ptr</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>这里我们注意， 屏障技术是不在栈上应用的，因为要保证栈的运行效率。</p></blockquote><h3 id=混合写屏障的具体场景分析>混合写屏障的具体场景分析
<a class=header-anchor href=#%e6%b7%b7%e5%90%88%e5%86%99%e5%b1%8f%e9%9a%9c%e7%9a%84%e5%85%b7%e4%bd%93%e5%9c%ba%e6%99%af%e5%88%86%e6%9e%90></a></h3><p>接下来，我们用几张图，来模拟整个一个详细的过程， 希望您能够更可观的看清晰整体流程。</p><blockquote><p>注意混合写屏障是Gc的一种屏障机制，所以只是当程序执行GC的时候，才会触发这种机制。</p></blockquote><h4 id=gc开始扫描栈区将可达对象全部标记为黑>GC开始：扫描栈区，将可达对象全部标记为黑
<a class=header-anchor href=#gc%e5%bc%80%e5%a7%8b%e6%89%ab%e6%8f%8f%e6%a0%88%e5%8c%ba%e5%b0%86%e5%8f%af%e8%be%be%e5%af%b9%e8%b1%a1%e5%85%a8%e9%83%a8%e6%a0%87%e8%ae%b0%e4%b8%ba%e9%bb%91></a></h4><p><img src=/imgs/img-lazy-loading.gif data-src=/images/cd30cf15-058a-4a64-a2f8-775c87dfea89.png alt></p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/a9c3a537-6c7b-4d07-8fc7-6f1c4c181cfb.png alt></p><hr><h4 id=场景一-对象被一个堆对象删除引用成为栈对象的下游>场景一： 对象被一个堆对象删除引用，成为栈对象的下游
<a class=header-anchor href=#%e5%9c%ba%e6%99%af%e4%b8%80-%e5%af%b9%e8%b1%a1%e8%a2%ab%e4%b8%80%e4%b8%aa%e5%a0%86%e5%af%b9%e8%b1%a1%e5%88%a0%e9%99%a4%e5%bc%95%e7%94%a8%e6%88%90%e4%b8%ba%e6%a0%88%e5%af%b9%e8%b1%a1%e7%9a%84%e4%b8%8b%e6%b8%b8></a></h4><blockquote><p>伪代码</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>//前提：堆对象4-&gt;对象7 = 对象7；  //对象7 被 对象4引用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>栈对象1</span><span style=color:#f92672>-</span>&gt;<span style=color:#a6e22e>对象7</span> = <span style=color:#a6e22e>堆对象7</span><span style=color:#960050;background-color:#1e0010>；</span>  <span style=color:#75715e>//将堆对象7 挂在 栈对象1 下游
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>堆对象4</span><span style=color:#f92672>-</span>&gt;<span style=color:#a6e22e>对象7</span> = <span style=color:#a6e22e>null</span><span style=color:#960050;background-color:#1e0010>；</span>    <span style=color:#75715e>//对象4 删除引用 对象7
</span></span></span></code></pre></div><p><img src=/imgs/img-lazy-loading.gif data-src=/images/ebaedc9a-8cd0-4598-8962-2f2e7fb3ac36.png alt></p><hr><p><img src=/imgs/img-lazy-loading.gif data-src=/images/a3066126-ad87-44a0-b712-4e80b69ad25d.png alt></p><h4 id=场景二-对象被一个栈对象删除引用成为另一个栈对象的下游>场景二： 对象被一个栈对象删除引用，成为另一个栈对象的下游
<a class=header-anchor href=#%e5%9c%ba%e6%99%af%e4%ba%8c-%e5%af%b9%e8%b1%a1%e8%a2%ab%e4%b8%80%e4%b8%aa%e6%a0%88%e5%af%b9%e8%b1%a1%e5%88%a0%e9%99%a4%e5%bc%95%e7%94%a8%e6%88%90%e4%b8%ba%e5%8f%a6%e4%b8%80%e4%b8%aa%e6%a0%88%e5%af%b9%e8%b1%a1%e7%9a%84%e4%b8%8b%e6%b8%b8></a></h4><blockquote><p>伪代码</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>new</span> <span style=color:#a6e22e>栈对象9</span><span style=color:#960050;background-color:#1e0010>；</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>对象8</span><span style=color:#f92672>-</span>&gt;<span style=color:#a6e22e>对象3</span> = <span style=color:#a6e22e>对象3</span><span style=color:#960050;background-color:#1e0010>；</span>      <span style=color:#75715e>//将栈对象3 挂在 栈对象9 下游
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>对象2</span><span style=color:#f92672>-</span>&gt;<span style=color:#a6e22e>对象3</span> = <span style=color:#a6e22e>null</span><span style=color:#960050;background-color:#1e0010>；</span>      <span style=color:#75715e>//对象2 删除引用 对象3
</span></span></span></code></pre></div><hr><p><img src=/imgs/img-lazy-loading.gif data-src=/images/4899f7b2-d951-4d9c-9880-6fb79fa01fee.png alt></p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/a185fd86-0ca0-4294-9ebf-6c8a73f8af19.png alt></p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/eb499138-8d6a-4c75-a4a9-1dad614879bf.png alt></p><hr><h4 id=场景三对象被一个堆对象删除引用成为另一个堆对象的下游>场景三：对象被一个堆对象删除引用，成为另一个堆对象的下游
<a class=header-anchor href=#%e5%9c%ba%e6%99%af%e4%b8%89%e5%af%b9%e8%b1%a1%e8%a2%ab%e4%b8%80%e4%b8%aa%e5%a0%86%e5%af%b9%e8%b1%a1%e5%88%a0%e9%99%a4%e5%bc%95%e7%94%a8%e6%88%90%e4%b8%ba%e5%8f%a6%e4%b8%80%e4%b8%aa%e5%a0%86%e5%af%b9%e8%b1%a1%e7%9a%84%e4%b8%8b%e6%b8%b8></a></h4><blockquote><p>伪代码</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>堆对象10</span><span style=color:#f92672>-</span>&gt;<span style=color:#a6e22e>对象7</span> = <span style=color:#a6e22e>堆对象7</span><span style=color:#960050;background-color:#1e0010>；</span>       <span style=color:#75715e>//将堆对象7 挂在 堆对象10 下游
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>堆对象4</span><span style=color:#f92672>-</span>&gt;<span style=color:#a6e22e>对象7</span> = <span style=color:#a6e22e>null</span><span style=color:#960050;background-color:#1e0010>；</span>         <span style=color:#75715e>//对象4 删除引用 对象7
</span></span></span></code></pre></div><hr><p><img src=/imgs/img-lazy-loading.gif data-src=/images/cb9a84fe-73ec-43e7-9d37-f14683e4f6e4.png alt></p><hr><p><img src=/imgs/img-lazy-loading.gif data-src=/images/e010d5a5-4867-43df-8e82-1a4368f2c8e2.png alt></p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/d11efffb-50de-4aed-b6a6-06eb20a4824e.png alt></p><hr><h4 id=场景四对象从一个栈对象删除引用成为另一个堆对象的下游>场景四：对象从一个栈对象删除引用，成为另一个堆对象的下游
<a class=header-anchor href=#%e5%9c%ba%e6%99%af%e5%9b%9b%e5%af%b9%e8%b1%a1%e4%bb%8e%e4%b8%80%e4%b8%aa%e6%a0%88%e5%af%b9%e8%b1%a1%e5%88%a0%e9%99%a4%e5%bc%95%e7%94%a8%e6%88%90%e4%b8%ba%e5%8f%a6%e4%b8%80%e4%b8%aa%e5%a0%86%e5%af%b9%e8%b1%a1%e7%9a%84%e4%b8%8b%e6%b8%b8></a></h4><blockquote><p>伪代码</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>堆对象10</span><span style=color:#f92672>-</span>&gt;<span style=color:#a6e22e>对象7</span> = <span style=color:#a6e22e>堆对象7</span><span style=color:#960050;background-color:#1e0010>；</span>       <span style=color:#75715e>//将堆对象7 挂在 堆对象10 下游
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>堆对象4</span><span style=color:#f92672>-</span>&gt;<span style=color:#a6e22e>对象7</span> = <span style=color:#a6e22e>null</span><span style=color:#960050;background-color:#1e0010>；</span>         <span style=color:#75715e>//对象4 删除引用 对象7
</span></span></span></code></pre></div><hr><p><img src=/imgs/img-lazy-loading.gif data-src=/images/29e311a4-4387-4387-be10-06bf33338c01.png alt></p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/ba80f06b-42a9-463d-b88f-62ee6f83bc4d.png alt></p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/497960cd-b419-430a-90e5-88f2e37bc848.png alt></p><hr><p>​ Golang中的混合写屏障满足<code>弱三色不变式</code>，结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行re-scan操作了，减少了STW的时间。</p><h2 id=总结>总结
<a class=header-anchor href=#%e6%80%bb%e7%bb%93></a></h2><p>​ 以上便是Golang的GC全部的标记-清除逻辑及场景演示全过程。</p><p>GoV1.3- 普通标记清除法，整体过程需要启动STW，效率极低。</p><p>GoV1.5- 三色标记法， 堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描一次栈(需要STW)，效率普通</p><p>GoV1.8-三色标记法，混合写屏障机制， 栈空间不启动，堆空间启动。整个过程几乎不需要STW，效率较高。</p><h2 id=文章转自>文章转自
<a class=header-anchor href=#%e6%96%87%e7%ab%a0%e8%bd%ac%e8%87%aa></a></h2><p><a href=https://www.jianshu.com/p/4c5a303af470 title=https://www.jianshu.com/p/4c5a303af470 rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://www.jianshu.com/p/4c5a303af470
<i class="fa fa-external-link-alt"></i></a></p></div><footer class=post-footer><div class=post-tags><a href=/tags/go>go</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right alt=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
golang GC 垃圾回收机制</li><li class=post-copyright-author><strong>本文作者： </strong>daemon365</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://daemon365.dev/post/go/golang_gc_garbage_collection_mechanism/ title="golang GC 垃圾回收机制">https://daemon365.dev/post/go/golang_gc_garbage_collection_mechanism/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/go/golang_channel_principle/ rel=next title="golang channel原理"><i class="fa fa-chevron-left"></i> golang channel原理</a></div><div class="post-nav-prev post-nav-item"><a href=/post/go/viper_configuration_management/ rel=prev title=viper配置管理>viper配置管理
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=utterances-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2019 - 2024
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>daemon365</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.138.0 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.6.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://daemon365.dev/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://daemon365.dev/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":false,"hostname":"https://daemon365.dev/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lawidget":{"id":"JmAHxEAUVgyS8B1c","js":"https://v6-widget.51.la/v6/laId/quote.js?theme=0\u0026col=true\u0026f=12\u0026display=0,0,0,1,0,1,1,1"},"lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":false,"enable":false,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":true,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"utterances":{"cfg":{"issueterm":"pathname","label":"comments","repo":"daemon365/blog","theme":"preferred-color-scheme"},"js":"https://utteranc.es/client.js"},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://daemon365.dev/3rd"}},"version":"4.6.3"}</script><script type=text/javascript src=/js/main.min.67947911eede6b08b61e6da911bd723abeb33e549e5f17c600657105589e5d18.js defer></script></body></html>