<!doctype html><html lang=zh-CN data-theme=light><head><meta charset=UTF-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.136.5"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon.ico><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/favicon.ico><meta itemprop=name content="Go工程化 - 依赖注入"><meta itemprop=description content="Don't let yourself stop."><meta name=description content="Don't let yourself stop."><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="https://daemon365.dev/imgs/daemon365.png"><meta itemprop=keywords content="go,kratos,wire"><meta property="og:type" content="article"><meta property="og:title" content="Go工程化 - 依赖注入"><meta property="og:description" content="Don't let yourself stop."><meta property="og:image" content="/imgs/daemon365.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://daemon365.dev/post/kratos/go_engineering___dependency_injection/"><meta property="og:site_name" content="Daemon"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="daemon365"><meta property="article:published_time" content="2021-09-30 00:00:00 +0800 +0800"><meta property="article:modified_time" content="2021-09-30 00:00:00 +0800 +0800"><link type=text/css rel=stylesheet href=https://daemon365.dev/3rd/font-awesome/6.6.0/css/all.min.css><link type=text/css rel=stylesheet href=https://daemon365.dev/3rd/animate.css/4.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://daemon365.dev/3rd/viewerjs/1.11.6/viewer.min.css><link rel=stylesheet href=/css/main.min.db412bd9ac28b4d2ef3191f82f07ea936e2d087816acf6d6ed4bc87362c7e9f0.css><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":true,"isHome":false,"isPage":true,"path":"go_engineering___dependency_injection","permalink":"https://daemon365.dev/post/kratos/go_engineering___dependency_injection/","title":"Go工程化 - 依赖注入","waline":{"js":[{"alias":"@waline/client","alias_name":"waline","file":"dist/pageview.js","name":"pageview","version":"2.15.8"},{"alias":"@waline/client","alias_name":"waline","file":"dist/comment.js","name":"comment","version":"2.15.8"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.id="LA_COLLECT",e.src="https://sdk.51.la/js-sdk-pro.min.js",e.async="true",e.onload=function(){LA.init({id:"JmAHxEAUVgyS8B1c",ck:"JmAHxEAUVgyS8B1c",autoTrack:!0})},document.head.appendChild(e)})</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>Go工程化 - 依赖注入 - Daemon</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Daemon</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>Don't let yourself stop.</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>Home</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>About</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>Archives
<span class=badge>93</span></a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>Commonweal</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#what>What</a></li><li><a href=#why>Why</a><ul><li><a href=#理解依赖注入>理解依赖注入</a><ul><li><a href=#依赖是什么>依赖是什么？</a></li><li><a href=#注入到哪里>注入到哪里？</a></li><li><a href=#不-di-是啥样di-了又样子>不 DI 是啥样？DI 了又样子？</a></li></ul></li></ul></li><li><a href=#how>How</a><ul><li><a href=#重新理解>重新理解</a><ul><li><a href=#谁参与编译>谁参与编译？</a></li><li><a href=#injector-是什么鬼东西>Injector 是什么鬼东西？</a></li><li><a href=#provider-是什么鬼东西>Provider 是什么鬼东西？</a></li><li><a href=#wire-工具做了啥>wire 工具做了啥？</a></li><li><a href=#总结>总结</a></li></ul></li></ul></li><li><a href=#文章转自>文章转自</a></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=daemon365 src=/imgs/img-lazy-loading.gif data-src=/imgs/daemon365.png><p class=site-author-name itemprop=name>daemon365</p><div class=site-description itemprop=description>Don't let yourself stop.</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>93</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>7</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>52</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/daemon365 title="Github → https://github.com/daemon365" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://go-kratos.dev title=https://go-kratos.dev target=_blank>kratos</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-comments class="button goto-comments" title=直达评论><i class="fas fa-comments"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script><script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://daemon365.dev/post/kratos/go_engineering___dependency_injection/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/daemon365.png"><meta itemprop=name content="daemon365"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="daemon365"><meta itemprop=description content="Don't let yourself stop."></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Go工程化 - 依赖注入"><meta itemprop=description content="我们在微服务框架

    kratos v2
    
    
    
的默认项目模板中

    kratos-layout
    
    
    
使用了

    google/wire
    
    
    
进行依赖注入，也建议开发者在维护项目时使用该工具。
wire 乍看起来比较违反直觉，导致很多同学不理解为什么要用或不清楚如何用（也包括曾经的我），本文来帮助大家理解 wire 的使用。"></span><header class=post-header><h1 class=post-title itemprop="name headline">Go工程化 - 依赖注入</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-calendar"></i>
</span><span class=post-meta-item-text title=发表于>发表于：
</span><time title="创建时间：2021-09-30 00:00:00 +0800 +0800" itemprop="dateCreated datePublished" datetime="2021-09-30 00:00:00 +0800 +0800">2021-09-30
</time></span><span class=post-meta-item><span class=post-meta-item-icon><i class="fas fa-solid fa-folder-open"></i>
</span><span class=post-meta-item-text title=分类于>分类于：
</span><span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/kratos itemprop=url rel=index><span itemprop=name>kratos</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="fas fa-solid fa-file-word"></i>
</span><span class=post-meta-item-text>字数：</span>
<span>5435</span>
</span><span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="fas fa-solid fa-clock"></i>
</span><span class=post-meta-item-text>阅读：&ap;</span>
<span>11分钟</span>
</span><span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="fas fa-solid fa-eye"></i>
</span><span class=post-meta-item-text>浏览：
</span><span id=busuanzi_value_page_pv data-path=/post/kratos/go_engineering___dependency_injection/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class=post-body itemprop=articleBody><p>我们在微服务框架
<a href=https://github.com/go-kratos/kratos title="kratos v2" rel="noopener external nofollow noreferrer" target=_blank class=exturl>kratos v2
<i class="fa fa-external-link-alt"></i>
</a>的默认项目模板中
<a href=https://github.com/go-kratos/kratos-layout title=kratos-layout rel="noopener external nofollow noreferrer" target=_blank class=exturl>kratos-layout
<i class="fa fa-external-link-alt"></i>
</a>使用了
<a href=https://github.com/google/wire title=google/wire rel="noopener external nofollow noreferrer" target=_blank class=exturl>google/wire
<i class="fa fa-external-link-alt"></i>
</a>进行依赖注入，也建议开发者在维护项目时使用该工具。</p><p>wire 乍看起来比较违反直觉，导致很多同学不理解为什么要用或不清楚如何用（也包括曾经的我），本文来帮助大家理解 wire 的使用。</p><h2 id=what>What
<a class=header-anchor href=#what></a></h2><p><a href=https://github.com/google/wire title=wire rel="noopener external nofollow noreferrer" target=_blank class=exturl>wire
<i class="fa fa-external-link-alt"></i>
</a>是由 google 开源的一个供 Go 语言使用的依赖注入代码生成工具。它能够根据你的代码，生成相应的依赖注入 go 代码。</p><p>而与其它依靠反射实现的依赖注入工具不同的是，wire 能在编译期（准确地说是代码生成时）如果依赖注入有问题，在代码生成时即可报出来，不会拖到运行时才报，更便于 debug。</p><h2 id=why>Why
<a class=header-anchor href=#why></a></h2><h3 id=理解依赖注入>理解依赖注入
<a class=header-anchor href=#%e7%90%86%e8%a7%a3%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5></a></h3><p>什么是依赖注入？为什么要依赖注入？
<del>依赖注入就是 Java 遗毒</del>（不是）</p><p><a href=https://zh.wikipedia.org/wiki/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5 title=依赖注入 rel="noopener external nofollow noreferrer" target=_blank class=exturl>依赖注入
<i class="fa fa-external-link-alt"></i>
</a>(Dependency Injection，缩写为 DI)，可以理解为一种代码的构造模式（就是写法），按照这样的方式来写，能够让你的代码更加容易维护。</p><p>对于很多软件设计模式和架构的理念，我们都无法理解他们要绕好大一圈做复杂的体操、用奇怪的方式进行实现的意义。他们通常都只是丢出来一段样例，说这样写就很好很优雅，由于省略掉了这种模式是如何发展出来的推导过程，我们只看到了结果，导致理解起来很困难。那么接下来我们来尝试推导还原一下整个过程，看看代码是如何和为什么演进到依赖注入模式的，以便能够更好理解使用依赖注入的意义。</p><h4 id=依赖是什么>依赖是什么？
<a class=header-anchor href=#%e4%be%9d%e8%b5%96%e6%98%af%e4%bb%80%e4%b9%88></a></h4><p>这里的依赖是个名词，不是指软件包的依赖（比如那坨塞在 node_modules 里面的东西），而是指软件中某一个模块（对象/实例）所依赖的其它外部模块（对象/实例）。</p><h4 id=注入到哪里>注入到哪里？
<a class=header-anchor href=#%e6%b3%a8%e5%85%a5%e5%88%b0%e5%93%aa%e9%87%8c></a></h4><p>被依赖的模块，在创建模块时，被注入到（即当作参数传入）模块的里面。</p><h4 id=不-di-是啥样di-了又样子>不 DI 是啥样？DI 了又样子？
<a class=header-anchor href=#%e4%b8%8d-di-%e6%98%af%e5%95%a5%e6%a0%b7di-%e4%ba%86%e5%8f%88%e6%a0%b7%e5%ad%90></a></h4><p>下面用 go 伪代码来做例子，领会精神即可。</p><p>假设个场景，你在打工搞一个 web 应用，它有一个简单接口。最开始的项目代码可能长这个样子：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#a6e22e>下面为伪代码</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>忽略了很多与主题无关的细节</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>App</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#a6e22e>假设这个方法将会匹配并处理</span> <span style=color:#a6e22e>GET</span> <span style=color:#f92672>/</span><span style=color:#a6e22e>biu</span><span style=color:#f92672>/</span>&lt;<span style=color:#a6e22e>id</span>&gt; <span style=color:#a6e22e>这样的请求</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>App</span>) <span style=color:#a6e22e>GetData</span>(<span style=color:#a6e22e>id</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#a6e22e>todo</span>: <span style=color:#a6e22e>write</span> <span style=color:#a6e22e>your</span> <span style=color:#a6e22e>data</span> <span style=color:#a6e22e>query</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;some data&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewApp</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>App</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>App</span>{}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>App</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>Run</span>()
</span></span></code></pre></div><p>你要做的是接一个 mysql，从里面把数据按照 id 查出来，返回。
要连 mysql 的话，假设我们已经有了个<code>NewMySQLClient</code>的方法返回 client 给你，初始化时传个地址进去就能拿到数据库连接，并假设它有个<code>Exec</code>的方法给你执行参数。</p><h5 id=不用-di通过全局变量传递依赖实例>不用 DI，通过全局变量传递依赖实例
<a class=header-anchor href=#%e4%b8%8d%e7%94%a8-di%e9%80%9a%e8%bf%87%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e4%bc%a0%e9%80%92%e4%be%9d%e8%b5%96%e5%ae%9e%e4%be%8b></a></h5><p>一种写法是，在外面全局初始化好 client，然后 App 直接拿来调用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>mysqlUrl</span> = <span style=color:#e6db74>&#34;mysql://blabla&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>db</span> = <span style=color:#a6e22e>NewMySQLClient</span>(<span style=color:#a6e22e>mysqlUrl</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>App</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>App</span>) <span style=color:#a6e22e>GetData</span>(<span style=color:#a6e22e>id</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Exec</span>(<span style=color:#e6db74>&#34;select data from biu where id = ? limit 1&#34;</span>, <span style=color:#a6e22e>id</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>data</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewApp</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>App</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>App</span>{}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>app</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>App</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>Run</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这就是没用依赖注入，app 依赖了全局变量 db，这是比较糟糕的一种做法。db 这个对象游离在全局作用域，暴露给包下的其他模块，比较危险。（设想如果这个包里其他代码在运行时悄悄把你的这个 db 变量替换掉会发生啥）</p><h5 id=不用-di在-app-的初始化方法里创建依赖实例>不用 DI，在 App 的初始化方法里创建依赖实例
<a class=header-anchor href=#%e4%b8%8d%e7%94%a8-di%e5%9c%a8-app-%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e6%96%b9%e6%b3%95%e9%87%8c%e5%88%9b%e5%bb%ba%e4%be%9d%e8%b5%96%e5%ae%9e%e4%be%8b></a></h5><p>另一种方式是这样的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>App</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>db</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MySQLClient</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>App</span>) <span style=color:#a6e22e>GetData</span>(<span style=color:#a6e22e>id</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Exec</span>(<span style=color:#e6db74>&#34;select data from biu where id = ? limit 1&#34;</span>, <span style=color:#a6e22e>id</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>data</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewApp</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>App</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>App</span>{<span style=color:#a6e22e>db</span>: <span style=color:#a6e22e>NewMySQLClient</span>(<span style=color:#a6e22e>mysqlUrl</span>)}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>app</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewApp</span>(<span style=color:#e6db74>&#34;mysql://blabla&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>Run</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这种方法稍微好一些，db 被塞到 app 里面了，不会有 app 之外的无关代码碰它，比较安全，但这依然不是依赖注入，而是在内部创建了依赖，接下来你会看到它带来的问题。</p><h5 id=老板我们的数据要换个地方存-需要变更实现>老板：我们的数据要换个地方存 （需要变更实现）
<a class=header-anchor href=#%e8%80%81%e6%9d%bf%e6%88%91%e4%bb%ac%e7%9a%84%e6%95%b0%e6%8d%ae%e8%a6%81%e6%8d%a2%e4%b8%aa%e5%9c%b0%e6%96%b9%e5%ad%98-%e9%9c%80%e8%a6%81%e5%8f%98%e6%9b%b4%e5%ae%9e%e7%8e%b0></a></h5><p>你的老板不知道从哪听说——Redis 贼特么快，要不我们的数据改从 Redis 里读吧。这个时候你的内心有点崩溃，但毕竟要恰饭的，就硬着头皮改上面的代码。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>App</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ds</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RedisClient</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>App</span>) <span style=color:#a6e22e>GetData</span>(<span style=color:#a6e22e>id</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>ds</span>.<span style=color:#a6e22e>Do</span>(<span style=color:#e6db74>&#34;GET&#34;</span>, <span style=color:#e6db74>&#34;biu_&#34;</span><span style=color:#f92672>+</span><span style=color:#a6e22e>id</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>data</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewApp</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>App</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>App</span>{<span style=color:#a6e22e>ds</span>: <span style=color:#a6e22e>NewRedisClient</span>(<span style=color:#a6e22e>redisAddr</span>)}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>app</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewApp</span>(<span style=color:#e6db74>&#34;redis://ooo&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>Run</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上面基本进行了 3 处修改：</p><ol><li>App 初始化方法里改成了初始化 RedisClient</li><li>get_data 里取数据时改用 run 方法，并且查询语句也换了</li><li>App 实例化时传入的参数改成了 redis 地址</li></ol><h5 id=老板要不我们再换个地方存我们要加测试需要-mock>老板：要不，我们再换个地方存？/我们要加测试，需要 Mock
<a class=header-anchor href=#%e8%80%81%e6%9d%bf%e8%a6%81%e4%b8%8d%e6%88%91%e4%bb%ac%e5%86%8d%e6%8d%a2%e4%b8%aa%e5%9c%b0%e6%96%b9%e5%ad%98%e6%88%91%e4%bb%ac%e8%a6%81%e5%8a%a0%e6%b5%8b%e8%af%95%e9%9c%80%e8%a6%81-mock></a></h5><p>老板的思路总是很广的，又过了两天他又想换成 Postgres 存了；或者让你们给 App 写点测试代码，只测接口里面的逻辑，通常我们不太愿意在旁边再起一个数据库，那么就需要 mock 掉数据源这块东西，让它直接返回数据给请求的 handler 用，来进行针对性的测试。</p><p>这种情况怎么办？再改里面的代码？这不科学。</p><h5 id=面向接口编程>面向接口编程
<a class=header-anchor href=#%e9%9d%a2%e5%90%91%e6%8e%a5%e5%8f%a3%e7%bc%96%e7%a8%8b></a></h5><p>一个很重要的思路就是要<strong>面向接口(interface)编程</strong>，而不是面向具体实现编程。</p><p>什么叫面向具体实现编程呢？比如上述的例子里改动的部分：调 mysqlclient 的 exec_sql 执行一条 sql，被改成了：调 redisclient 的 do 执行一句 get 指令。由于每种 client 的接口设计不同，每换一个实现，就得改一遍。</p><p>而面向接口编程的思路，则完全不同。我们不要听老板想用啥就马上写代码。首先就得预料到，这个数据源的实现很有可能被更换，因此在一开始就应该做好准备（设计）。</p><h6 id=设计接口>设计接口
<a class=header-anchor href=#%e8%ae%be%e8%ae%a1%e6%8e%a5%e5%8f%a3></a></h6><p>Python 里面有个概念叫鸭子类型(duck-typing)，就是如果你叫起来像鸭子，走路像鸭子，游泳像鸭子，那么你就是一只鸭子。这里的叫、走路、游泳就是我们约定的鸭子接口，而你如果完整实现了这些接口，我们可以像对待一个鸭子一样对待你。</p><p>在我们上面的例子中，不论是 Mysql 实现还是 Redis 实现，他们都有个共同的功能：用一个 id，查一个数据出来，那么这就是共同的接口。</p><p>我们可以约定一个叫 DataSource 的接口，它必须有一个方法叫 GetById，功能是要接收一个 id，返回一个字符串</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>DataSource</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>GetById</span>(<span style=color:#a6e22e>id</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然后我们就可以把各个数据源分别进行封装，按照这个 interface 定义实现接口，这样我们的 App 里处理请求的部分就可以稳定地调用 GetById 这个方法，而底层数据实现只要实现了 DataSource 这个 interface 就能花式替换，不用改 App 内部的代码了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 封装个redis
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>redis</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RedisClient</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewRedis</span>(<span style=color:#a6e22e>addr</span> <span style=color:#66d9ef>string</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>redis</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>redis</span>{<span style=color:#a6e22e>r</span>: <span style=color:#a6e22e>NewRedisClient</span>(<span style=color:#a6e22e>addr</span>)}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>redis</span>) <span style=color:#a6e22e>GetById</span>(<span style=color:#a6e22e>id</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Do</span>(<span style=color:#e6db74>&#34;GET&#34;</span>, <span style=color:#e6db74>&#34;biu_&#34;</span><span style=color:#f92672>+</span><span style=color:#a6e22e>id</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 再封装个mysql
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>mysql</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>MySQLClient</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewMySQL</span>(<span style=color:#a6e22e>addr</span> <span style=color:#66d9ef>string</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>redis</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>mysql</span>{<span style=color:#a6e22e>m</span>: <span style=color:#a6e22e>NewMySQLClient</span>(<span style=color:#a6e22e>addr</span>)}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>mysql</span>) <span style=color:#a6e22e>GetById</span>(<span style=color:#a6e22e>id</span> <span style=color:#66d9ef>string</span>) <span style=color:#66d9ef>string</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Exec</span>(<span style=color:#e6db74>&#34;select data from biu where id = ? limit 1&#34;</span>, <span style=color:#a6e22e>id</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>App</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ds</span> <span style=color:#a6e22e>DataSource</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewApp</span>(<span style=color:#a6e22e>addr</span> <span style=color:#66d9ef>string</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>App</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//需要用Mysql的时候
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>App</span>{<span style=color:#a6e22e>ds</span>: <span style=color:#a6e22e>NewMySQLClient</span>(<span style=color:#a6e22e>addr</span>)}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//需要用Redis的时候
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>App</span>{<span style=color:#a6e22e>ds</span>: <span style=color:#a6e22e>NewRedisClient</span>(<span style=color:#a6e22e>addr</span>)}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>由于两种数据源都实现了 DataSource 接口，因此可以直接创建一个塞到 App 里面了，想用哪个用哪个，看着还不错？</p><h5 id=等一等好像少了些什么>等一等，好像少了些什么
<a class=header-anchor href=#%e7%ad%89%e4%b8%80%e7%ad%89%e5%a5%bd%e5%83%8f%e5%b0%91%e4%ba%86%e4%ba%9b%e4%bb%80%e4%b9%88></a></h5><p>addr 作为参数，是不是有点简单？通常初始化一个数据库连接，可能有一堆参数，配在一个 yaml 文件里，需要解析到一个 struct 里面，然后再传给对应的 New 方法。</p><p>配置文件可能是这样的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>redis</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>addr</span>: <span style=color:#ae81ff>127.0.0.1</span>:<span style=color:#ae81ff>6379</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>read_timeout</span>: <span style=color:#ae81ff>0.</span><span style=color:#ae81ff>2s</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>write_timeout</span>: <span style=color:#ae81ff>0.</span><span style=color:#ae81ff>2s</span>
</span></span></code></pre></div><p>解析结构体是这样的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>RedisConfig</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Network</span>      <span style=color:#66d9ef>string</span>             <span style=color:#e6db74>`json:&#34;network,omitempty&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>Addr</span>         <span style=color:#66d9ef>string</span>             <span style=color:#e6db74>`json:&#34;addr,omitempty&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ReadTimeout</span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>duration</span>.<span style=color:#a6e22e>Duration</span> <span style=color:#e6db74>`json:&#34;read_timeout,omitempty&#34;`</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>WriteTimeout</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>duration</span>.<span style=color:#a6e22e>Duration</span> <span style=color:#e6db74>`json:&#34;write_timeout,omitempty&#34;`</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>结果你的<code>NewApp</code>方法可能就变成了这个德性：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewApp</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>App</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>conf</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RedisConfig</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>yamlFile</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>ReadFile</span>(<span style=color:#e6db74>&#34;redis_conf.yaml&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>yaml</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>yamlFile</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>conf</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>App</span>{<span style=color:#a6e22e>ds</span>: <span style=color:#a6e22e>NewRedisClient</span>(<span style=color:#a6e22e>conf</span>)}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>NewApp 说，停停，你们年轻人不讲武德，我的责任就是创建一个 App 实例，我只需要一个 DataSource 注册进去，至于这个 DataSource 是怎么来的我不想管，这么一坨处理 conf 的代码凭什么要放在我这里，我也不想关心你这配置文件是通过网络请求拿来的还是从本地磁盘读的，我只想把 App 组装好扔出去直接下班。</p><h5 id=依赖注入终于可以登场了>依赖注入终于可以登场了
<a class=header-anchor href=#%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5%e7%bb%88%e4%ba%8e%e5%8f%af%e4%bb%a5%e7%99%bb%e5%9c%ba%e4%ba%86></a></h5><p>还记得前面是怎么说依赖注入的吗？被依赖的模块，在创建模块时，被注入到（即当作参数传入）初始化函数里面。通过这种模式，正好可以让 NewApp 早点下班。我们在外面初始化好 NewRedis 或者 NewMysql，得到的 DataSource 直接扔给 NewApp。</p><p>也就是这样</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewApp</span>(<span style=color:#a6e22e>ds</span> <span style=color:#a6e22e>DataSource</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>App</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>App</span>{<span style=color:#a6e22e>ds</span>: <span style=color:#a6e22e>ds</span>}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>那坨读配置文件初始化 redis 的代码扔到初始化 DataSource 的方法里去</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewRedis</span>() <span style=color:#a6e22e>DataSource</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>conf</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RedisConfig</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>yamlFile</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ioutil</span>.<span style=color:#a6e22e>ReadFile</span>(<span style=color:#e6db74>&#34;redis_conf.yaml&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>err</span> = <span style=color:#a6e22e>yaml</span>.<span style=color:#a6e22e>Unmarshal</span>(<span style=color:#a6e22e>yamlFile</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>conf</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        panic(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>redis</span>{<span style=color:#a6e22e>r</span>: <span style=color:#a6e22e>NewRedisClient</span>(<span style=color:#a6e22e>conf</span>)}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>更进一步，NewRedis 这个方法甚至也不需要关心文件是怎么读的，它的责任只是通过 conf 初始化一个 DataSource 出来，因此你可以继续把读 config 的代码往外抽，把 NewRedis 做成接收一个 conf，输出一个 DataSource</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>GetRedisConf</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>RedisConfig</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>NewRedis</span>(<span style=color:#a6e22e>conf</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>RedisConfig</span>) <span style=color:#a6e22e>DataSource</span>
</span></span></code></pre></div><p>因为之前整个组装过程是散放在 main 函数下面的，我们把它抽出来搞成一个独立的 initApp 方法。最后你的 App 初始化逻辑就变成了这样</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>initApp</span>() <span style=color:#f92672>*</span><span style=color:#a6e22e>App</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>GetRedisConf</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewRedis</span>(<span style=color:#a6e22e>c</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>app</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewApp</span>(<span style=color:#a6e22e>r</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>app</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>app</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>initApp</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>app</span>.<span style=color:#a6e22e>Run</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然后你可以通过实现 DataSource 的接口，更换前面的读取配置文件的方法，和更换创建 DataSource 的方法，来任意修改你的底层实现（读配置文件的实现，和用哪种 DataSource 来查数据），而不用每次都改一大堆代码。这使得你的代码层次划分得更加清楚，更容易维护了。</p><p>这就是依赖注入。</p><h5 id=手工依赖注入的问题>手工依赖注入的问题
<a class=header-anchor href=#%e6%89%8b%e5%b7%a5%e4%be%9d%e8%b5%96%e6%b3%a8%e5%85%a5%e7%9a%84%e9%97%ae%e9%a2%98></a></h5><p>上文这一坨代码，把各个实例初始化好，再按照各个初始化方法的需求塞进去，最终构造出 app 的这坨代码，就是注入依赖的过程。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>GetRedisConf</span>()
</span></span><span style=display:flex><span><span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewRedis</span>(<span style=color:#a6e22e>c</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>app</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>NewApp</span>(<span style=color:#a6e22e>r</span>)
</span></span></code></pre></div><p>目前只有一个 DataSource，这样手写注入过程还可以，一旦你要维护的东西多了，比如你的 NewApp 是这样的<code>NewApp(r *Redis, es *ES, us *UserSerivce, db *MySQL) *App</code>然后其中 UserService 是这样的<code>UserService(pg *Postgres, mm *Memcached)</code>，这样形成了多层次的一堆依赖需要注入，徒手去写非常麻烦。</p><p>而这部分，就是 wire 这样的依赖注入工具能够起作用的地方了——他的功能只是通过生成代码<strong>帮你注入依赖</strong>，而实际的依赖实例需要你自己创建（初始化）。</p><h2 id=how>How
<a class=header-anchor href=#how></a></h2><p>wire 的主要问题是，<del>看文档学不会</del>。反正我最初看完文档之后是一头雾水——这是啥，这要干啥？但通过我们刚才的推导过程，应该大概理解了为什么要用依赖注入，以及 wire 在这其中起到什么作用——通过生成代码<strong>帮你注入依赖</strong>，而实际的依赖实例需要你自己创建（初始化）。</p><p>接下来就比较清楚了。</p><p>首先要实现一个<code>wire.go</code>的文件，里面定义好 Injector。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span><span style=color:#f92672>//</span> <span style=color:#f92672>+</span>build wireinject
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> initApp() (<span style=color:#f92672>*</span>App) {
</span></span><span style=display:flex><span>	panic(wire<span style=color:#f92672>.</span>Build(GetRedisConf, NewRedis, SomeProviderSet, NewApp))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>然后分别实现好 Provider。</p><p>执行<code>wire</code>命令后
他会扫描整个项目，并帮你生成一个<code>wire_gen.go</code>文件，如果你有什么没有实现好，它会报错出来。</p><p><del>你学会了吗？</del></p><h3 id=重新理解>重新理解
<a class=header-anchor href=#%e9%87%8d%e6%96%b0%e7%90%86%e8%a7%a3></a></h3><p>等一等，先别放弃治疗，让我们用<del>神奇的中文编程</del>来解释一下要怎么做。</p><h4 id=谁参与编译>谁参与编译？
<a class=header-anchor href=#%e8%b0%81%e5%8f%82%e4%b8%8e%e7%bc%96%e8%af%91></a></h4><p>上面那个<code>initApp</code>方法，官方文档叫它 Injector，由于文件里首行<code>// +build wireinject</code>这句注释，这个 wire.go 文件只会由 wire 读取，在 go 编译器在编译代码时不会去管它，实际会读的是生成的 wire_gen.go 文件。</p><p>而 Provider 就是你代码的一部分，肯定会参与到编译过程。</p><h4 id=injector-是什么鬼东西>Injector 是什么鬼东西？
<a class=header-anchor href=#injector-%e6%98%af%e4%bb%80%e4%b9%88%e9%ac%bc%e4%b8%9c%e8%a5%bf></a></h4><p>Injector 就是你最终想要的结果——最终的 App 对象的初始化函数，也就是前面那个例子里的<code>initApp</code>方法。</p><p>把它理解为你去吃金拱门，进门看到点餐机，噼里啪啦点了一堆，最后打出一张单子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// +build wireinject
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>来一袋垃圾食品</span>() <span style=color:#a6e22e>一袋垃圾食品</span> {
</span></span><span style=display:flex><span>    panic(<span style=color:#a6e22e>wire</span>.<span style=color:#a6e22e>Build</span>(<span style=color:#a6e22e>来一份巨无霸套餐</span>, <span style=color:#a6e22e>来一份双层鳕鱼堡套餐</span>, <span style=color:#a6e22e>来一盒麦乐鸡</span>, <span style=color:#a6e22e>垃圾食品打包</span>))
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这就是你点的单子，它不参与编译，实际参与编译的代码是由 wire 帮你生成的。</p><h4 id=provider-是什么鬼东西>Provider 是什么鬼东西？
<a class=header-anchor href=#provider-%e6%98%af%e4%bb%80%e4%b9%88%e9%ac%bc%e4%b8%9c%e8%a5%bf></a></h4><p>Provider 就是创建各个依赖的方法，比如前面例子里的 NewRedis 和 NewApp 等。</p><p>你可以理解为，这些是金拱门的服务员和后厨要干的事情：
金拱门后厨需要提供这些食品的制作服务——实现这些实例初始化方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>来一盒麦乐鸡</span>() <span style=color:#a6e22e>一盒麦乐鸡</span> {}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>垃圾食品打包</span>(<span style=color:#a6e22e>一份巨无霸套餐</span>, <span style=color:#a6e22e>一份双层鳕鱼堡套餐</span>, <span style=color:#a6e22e>一盒麦乐鸡</span>) <span style=color:#a6e22e>一袋垃圾食品</span> {}
</span></span></code></pre></div><p>wire 里面还有个 ProviderSet 的概念，就是把一组 Provider 打包，因为通常你点单的时候很懒，不想这样点你的巨无霸套餐：我要一杯可乐，一包薯条，一个巨无霸汉堡；你想直接戳一下就好了，来一份巨无霸套餐。这个套餐就是 ProviderSet，一组约定好的配方，不然你的点单列表（injector 里的 Build）就会变得超级长，这样你很麻烦，服务员看着也很累。</p><p>用其中一个套餐举例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 先定义套餐内容
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>巨无霸套餐</span> = <span style=color:#a6e22e>wire</span>.<span style=color:#a6e22e>NewSet</span>(<span style=color:#a6e22e>来一杯可乐</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>来一包薯条</span><span style=color:#960050;background-color:#1e0010>，</span><span style=color:#a6e22e>来一个巨无霸汉堡</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 然后实现各个食品的做法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>来一杯可乐</span>() <span style=color:#a6e22e>一杯可乐</span> {}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>来一包薯条</span>() <span style=color:#a6e22e>一包薯条</span> {}
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>来一个巨无霸汉堡</span>() <span style=color:#a6e22e>一个巨无霸汉堡</span> {}
</span></span></code></pre></div><h4 id=wire-工具做了啥>wire 工具做了啥？
<a class=header-anchor href=#wire-%e5%b7%a5%e5%85%b7%e5%81%9a%e4%ba%86%e5%95%a5></a></h4><p>重要的事情说三遍，通过生成代码<strong>帮你注入依赖</strong>。</p><p>在金拱门的例子里就是，wire 就是个服务员，它按照你的订单，去叫做相应的同事把各个食物/套餐做好，然后最终按需求打包给你。这个中间协调构建的过程，就是注入依赖。</p><p>这样的好处就是，
对于金拱门，假设他们突然换可乐供应商了，直接把<code>来一杯可乐</code>替换掉就行，返回一种新的可乐，而对于顾客不需要有啥改动。
对于顾客来说，点单内容可以变换，比如我今天不想要麦乐鸡了，或者想加点别的，只要改动我的点单(只要金拱门能做得出来)，然后通过 wire 重新去生成即可，不需要关注这个服务员是如何去做这个订单的。</p><p>现在你应该大概理解 wire 的用处和好处了。</p><h4 id=总结>总结
<a class=header-anchor href=#%e6%80%bb%e7%bb%93></a></h4><p>让我们从金拱门回来，重新总结一下用 wire 做依赖注入的过程。</p><h5 id=1-定义-injector>1. 定义 Injector
<a class=header-anchor href=#1-%e5%ae%9a%e4%b9%89-injector></a></h5><p>创建<code>wire.go</code>文件，定义下你最终想用的实例初始化函数例如<code>initApp</code>（即 Injector），定好它返回的东西<code>*App</code>，在方法里用<code>panic(wire.Build(NewRedis, SomeProviderSet, NewApp))</code>罗列出它依赖哪些实例的初始化方法（即 Provider）/或者哪些组初始化方法（ProviderSet）</p><h5 id=2-定义-providerset如果有的话>2. 定义 ProviderSet（如果有的话）
<a class=header-anchor href=#2-%e5%ae%9a%e4%b9%89-providerset%e5%a6%82%e6%9e%9c%e6%9c%89%e7%9a%84%e8%af%9d></a></h5><p>ProviderSet 就是一组初始化函数，是为了少写一些代码，能够更清晰的组织各个模块的依赖才出现的。也可以不用，但 Injector 里面的东西就需要写一堆。
像这样 <code>var SomeProviderSet = wire.NewSet(NewES,NewDB)</code>定义 ProviderSet 里面包含哪些 Provider</p><h5 id=3-实现各个-provider>3. 实现各个 Provider
<a class=header-anchor href=#3-%e5%ae%9e%e7%8e%b0%e5%90%84%e4%b8%aa-provider></a></h5><p>Provider 就是初始化方法，你需要自己实现，比如 NewApp，NewRedis，NewMySQL，GetConfig 等，注意他们们各自的输入输出</p><h5 id=4-生成代码>4. 生成代码
<a class=header-anchor href=#4-%e7%94%9f%e6%88%90%e4%bb%a3%e7%a0%81></a></h5><p>执行 wire 命令生成代码，工具会扫描你的代码，依照你的 Injector 定义来组织各个 Provider 的执行顺序，并自动按照 Provider 们的类型需求来按照顺序执行和安排参数传递，如果有哪些 Provider 的要求没有满足，会在终端报出来，持续修复执行 wire，直到成功生成<code>wire_gen.go</code>文件。接下来就可以正常使用<code>initApp</code>来写你后续的代码了。</p><p>如果需要替换实现，对 Injector 进行相应的修改，实现必须的 Provider，重新生成即可。</p><p>它生成的代码其实就是类似我们之前需要手写的这个</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-gdscript3 data-lang=gdscript3><span style=display:flex><span><span style=color:#66d9ef>func</span> initApp() <span style=color:#f92672>*</span>App {  <span style=color:#f92672>//</span> injector
</span></span><span style=display:flex><span>    c :<span style=color:#f92672>=</span> GetRedisConf() <span style=color:#f92672>//</span> provider
</span></span><span style=display:flex><span>    r :<span style=color:#f92672>=</span> NewRedis(c)  <span style=color:#f92672>//</span> provider
</span></span><span style=display:flex><span>    app :<span style=color:#f92672>=</span> NewApp(r) <span style=color:#f92672>//</span> provider
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> app
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>由于我们的例子比较简单，通过 wire 生成体现不出优势，但如果我们的软件复杂，有很多层级的依赖，使用 wire 自动生成注入逻辑，无疑更加方便和准确。</p><h5 id=5-高级用法>5. 高级用法
<a class=header-anchor href=#5-%e9%ab%98%e7%ba%a7%e7%94%a8%e6%b3%95></a></h5><p>wire 还有更多功能，比如 cleanup, bind 等等，请参考官方文档来使用。</p><p>最后，其实多折腾几次，就会使用了，希望本文能对您起到一定程度上的帮助。</p><h2 id=文章转自>文章转自
<a class=header-anchor href=#%e6%96%87%e7%ab%a0%e8%bd%ac%e8%87%aa></a></h2><ul><li><a href=https://go-kratos.dev/blog/go-project-wire title=https://go-kratos.dev/blog/go-project-wire rel="noopener external nofollow noreferrer" target=_blank class=exturl>https://go-kratos.dev/blog/go-project-wire
<i class="fa fa-external-link-alt"></i></a></li></ul><hr><p><img src=/imgs/img-lazy-loading.gif data-src=/images/b43c2417-ea24-4e28-b324-c53b433abc6c.png alt></p><p><img src=/imgs/img-lazy-loading.gif data-src=/images/3e44cb72-7234-4f8d-b02b-0ab484c79442.gif alt></p></div><footer class=post-footer><div class=post-tags><a href=/tags/go>go
</a><a href=/tags/kratos>kratos
</a><a href=/tags/wire>wire</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right alt=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong>
Go工程化 - 依赖注入</li><li class=post-copyright-author><strong>本文作者： </strong>daemon365</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://daemon365.dev/post/kratos/go_engineering___dependency_injection/ title="Go工程化 - 依赖注入">https://daemon365.dev/post/kratos/go_engineering___dependency_injection/</a></li><li class=post-copyright-license><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/cloud/makefile/ rel=next title=makefile><i class="fa fa-chevron-left"></i> makefile</a></div><div class="post-nav-prev post-nav-item"><a href=/post/kratos/kratos_v2_command_line_tool_usage/ rel=prev title="kratos v2版本命令行工具使用">kratos v2版本命令行工具使用
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div id=comments class=post-comments><div class=comment-head><div class=comment-headline><i class="fas fa-comments fa-fw"></i>
<span>评论交流</span></div></div><div class=comment-wrap><div><div class=comment-loading><i class="fa fa-sync fa-spin"></i></div><div class=utterances-container></div></div></div></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2019 - 2024
</span><span class=with-love><i class="fa fa-heart"></i>
</span><span class=author itemprop=copyrightHolder>daemon365</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.136.5 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.6.3 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://daemon365.dev/3rd/animejs/3.2.2/anime.min.js crossorigin=anonymous defer></script><script type=text/javascript src=https://daemon365.dev/3rd/viewerjs/1.11.6/viewer.min.js crossorigin=anonymous defer></script><script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":false,"hostname":"https://daemon365.dev/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lawidget":{"id":"JmAHxEAUVgyS8B1c","js":"https://v6-widget.51.la/v6/laId/quote.js?theme=0\u0026col=true\u0026f=12\u0026display=0,0,0,1,0,1,1,1"},"lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":false,"plugin":"waline"},"views":{"enable":true,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"utterances":{"cfg":{"issueterm":"pathname","label":"comments","repo":"daemon365/blog","theme":"preferred-color-scheme"},"js":"https://utteranc.es/client.js"},"vendor":{"plugins":"local","router":{"name":"local","type":"modern","url":"https://daemon365.dev/3rd"}},"version":"4.6.3"}</script><script type=text/javascript src=/js/main.min.44e8f3a116669418a0551fcbff81fe26c85707505ea0b87a42f2d4116994b442.js defer></script></body></html>